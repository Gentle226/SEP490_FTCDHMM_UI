"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/use-intl";
exports.ids = ["vendor-chunks/use-intl"];
exports.modules = {

/***/ "(rsc)/../../node_modules/use-intl/dist/esm/development/initializeConfig-DPFnvsUO.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/use-intl/dist/esm/development/initializeConfig-DPFnvsUO.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   I: () => (/* binding */ IntlError),\n/* harmony export */   a: () => (/* binding */ IntlErrorCode),\n/* harmony export */   b: () => (/* binding */ createIntlFormatters),\n/* harmony export */   c: () => (/* binding */ createFormatter),\n/* harmony export */   d: () => (/* binding */ createCache),\n/* harmony export */   e: () => (/* binding */ createBaseTranslator),\n/* harmony export */   f: () => (/* binding */ defaultGetMessageFallback),\n/* harmony export */   g: () => (/* binding */ defaultOnError),\n/* harmony export */   i: () => (/* binding */ initializeConfig),\n/* harmony export */   r: () => (/* binding */ resolveNamespace)\n/* harmony export */ });\n/* harmony import */ var intl_messageformat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! intl-messageformat */ \"(rsc)/../../node_modules/intl-messageformat/lib/src/core.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(rsc)/../../node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js\");\n/* harmony import */ var _formatjs_fast_memoize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @formatjs/fast-memoize */ \"(rsc)/../../node_modules/@formatjs/fast-memoize/lib/index.js\");\nconst _excluded = [\"formats\", \"getMessageFallback\", \"messages\", \"onError\"];\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\n\n\nclass IntlError extends Error {\n  constructor(code, originalMessage) {\n    let message = code;\n    if (originalMessage) {\n      message += ': ' + originalMessage;\n    }\n    super(message);\n    this.code = code;\n    if (originalMessage) {\n      this.originalMessage = originalMessage;\n    }\n  }\n}\nvar IntlErrorCode = /*#__PURE__*/function (IntlErrorCode) {\n  IntlErrorCode[\"MISSING_MESSAGE\"] = \"MISSING_MESSAGE\";\n  IntlErrorCode[\"MISSING_FORMAT\"] = \"MISSING_FORMAT\";\n  IntlErrorCode[\"ENVIRONMENT_FALLBACK\"] = \"ENVIRONMENT_FALLBACK\";\n  IntlErrorCode[\"INSUFFICIENT_PATH\"] = \"INSUFFICIENT_PATH\";\n  IntlErrorCode[\"INVALID_MESSAGE\"] = \"INVALID_MESSAGE\";\n  IntlErrorCode[\"INVALID_KEY\"] = \"INVALID_KEY\";\n  IntlErrorCode[\"FORMATTING_ERROR\"] = \"FORMATTING_ERROR\";\n  return IntlErrorCode;\n}(IntlErrorCode || {});\n\n/**\n * `intl-messageformat` uses separate keys for `date` and `time`, but there's\n * only one native API: `Intl.DateTimeFormat`. Additionally you might want to\n * include both a time and a date in a value, therefore the separation doesn't\n * seem so useful. We offer a single `dateTime` namespace instead, but we have\n * to convert the format before `intl-messageformat` can be used.\n */\nfunction convertFormatsToIntlMessageFormat(globalFormats, inlineFormats, timeZone) {\n  const mfDateDefaults = intl_messageformat__WEBPACK_IMPORTED_MODULE_2__.IntlMessageFormat.formats.date;\n  const mfTimeDefaults = intl_messageformat__WEBPACK_IMPORTED_MODULE_2__.IntlMessageFormat.formats.time;\n  const dateTimeFormats = _objectSpread(_objectSpread({}, globalFormats?.dateTime), inlineFormats?.dateTime);\n  const allFormats = {\n    date: _objectSpread(_objectSpread({}, mfDateDefaults), dateTimeFormats),\n    time: _objectSpread(_objectSpread({}, mfTimeDefaults), dateTimeFormats),\n    number: _objectSpread(_objectSpread({}, globalFormats?.number), inlineFormats?.number)\n    // (list is not supported in ICU messages)\n  };\n\n  if (timeZone) {\n    // The only way to set a time zone with `intl-messageformat` is to merge it into the formats\n    // https://github.com/formatjs/formatjs/blob/8256c5271505cf2606e48e3c97ecdd16ede4f1b5/packages/intl/src/message.ts#L15\n    ['date', 'time'].forEach(property => {\n      const formats = allFormats[property];\n      for (const [key, value] of Object.entries(formats)) {\n        formats[key] = _objectSpread({\n          timeZone\n        }, value);\n      }\n    });\n  }\n  return allFormats;\n}\nfunction joinPath(...parts) {\n  return parts.filter(Boolean).join('.');\n}\n\n/**\n * Contains defaults that are used for all entry points into the core.\n * See also `InitializedIntlConfiguration`.\n */\n\nfunction defaultGetMessageFallback(props) {\n  return joinPath(props.namespace, props.key);\n}\nfunction defaultOnError(error) {\n  console.error(error);\n}\nfunction createCache() {\n  return {\n    dateTime: {},\n    number: {},\n    message: {},\n    relativeTime: {},\n    pluralRules: {},\n    list: {},\n    displayNames: {}\n  };\n}\nfunction createMemoCache(store) {\n  return {\n    create() {\n      return {\n        get(key) {\n          return store[key];\n        },\n        set(key, value) {\n          store[key] = value;\n        }\n      };\n    }\n  };\n}\nfunction memoFn(fn, cache) {\n  return (0,_formatjs_fast_memoize__WEBPACK_IMPORTED_MODULE_1__.memoize)(fn, {\n    cache: createMemoCache(cache),\n    strategy: _formatjs_fast_memoize__WEBPACK_IMPORTED_MODULE_1__.strategies.variadic\n  });\n}\nfunction memoConstructor(ConstructorFn, cache) {\n  return memoFn((...args) => new ConstructorFn(...args), cache);\n}\nfunction createIntlFormatters(cache) {\n  const getDateTimeFormat = memoConstructor(Intl.DateTimeFormat, cache.dateTime);\n  const getNumberFormat = memoConstructor(Intl.NumberFormat, cache.number);\n  const getPluralRules = memoConstructor(Intl.PluralRules, cache.pluralRules);\n  const getRelativeTimeFormat = memoConstructor(Intl.RelativeTimeFormat, cache.relativeTime);\n  const getListFormat = memoConstructor(Intl.ListFormat, cache.list);\n  const getDisplayNames = memoConstructor(Intl.DisplayNames, cache.displayNames);\n  return {\n    getDateTimeFormat,\n    getNumberFormat,\n    getPluralRules,\n    getRelativeTimeFormat,\n    getListFormat,\n    getDisplayNames\n  };\n}\n\n// Placed here for improved tree shaking. Somehow when this is placed in\n// `formatters.tsx`, then it can't be shaken off from `next-intl`.\nfunction createMessageFormatter(cache, intlFormatters) {\n  const getMessageFormat = memoFn((...args) => new intl_messageformat__WEBPACK_IMPORTED_MODULE_2__.IntlMessageFormat(args[0], args[1], args[2], _objectSpread({\n    formatters: intlFormatters\n  }, args[3])), cache.message);\n  return getMessageFormat;\n}\nfunction resolvePath(locale, messages, key, namespace) {\n  const fullKey = joinPath(namespace, key);\n  if (!messages) {\n    throw new Error(`No messages available at \\`${namespace}\\`.`);\n  }\n  let message = messages;\n  key.split('.').forEach(part => {\n    const next = message[part];\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (part == null || next == null) {\n      throw new Error(`Could not resolve \\`${fullKey}\\` in messages for locale \\`${locale}\\`.`);\n    }\n    message = next;\n  });\n  return message;\n}\nfunction prepareTranslationValues(values) {\n  // Workaround for https://github.com/formatjs/formatjs/issues/1467\n  const transformedValues = {};\n  Object.keys(values).forEach(key => {\n    let index = 0;\n    const value = values[key];\n    let transformed;\n    if (typeof value === 'function') {\n      transformed = chunks => {\n        const result = value(chunks);\n        return /*#__PURE__*/ /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(result) ? /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(result, {\n          key: key + index++\n        }) : result;\n      };\n    } else {\n      transformed = value;\n    }\n    transformedValues[key] = transformed;\n  });\n  return transformedValues;\n}\nfunction getMessagesOrError(locale, messages, namespace, onError = defaultOnError) {\n  try {\n    if (!messages) {\n      throw new Error(`No messages were configured.`);\n    }\n    const retrievedMessages = namespace ? resolvePath(locale, messages, namespace) : messages;\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (!retrievedMessages) {\n      throw new Error(`No messages for namespace \\`${namespace}\\` found.`);\n    }\n    return retrievedMessages;\n  } catch (error) {\n    const intlError = new IntlError(IntlErrorCode.MISSING_MESSAGE, error.message);\n    onError(intlError);\n    return intlError;\n  }\n}\nfunction getPlainMessage(candidate, values) {\n  // To improve runtime performance, only compile message if:\n  return (\n    // 1. Values are provided\n    values ||\n    // 2. There are escaped braces (e.g. \"'{name'}\")\n    /'[{}]/.test(candidate) ||\n    // 3. There are missing arguments or tags (dev-only error handling)\n    /<|{/.test(candidate) ? undefined // Compile\n    : candidate // Don't compile\n  );\n}\n\nfunction createBaseTranslator(config) {\n  const messagesOrError = getMessagesOrError(config.locale, config.messages, config.namespace, config.onError);\n  return createBaseTranslatorImpl(_objectSpread(_objectSpread({}, config), {}, {\n    messagesOrError\n  }));\n}\nfunction createBaseTranslatorImpl({\n  cache,\n  formats: globalFormats,\n  formatters,\n  getMessageFallback = defaultGetMessageFallback,\n  locale,\n  messagesOrError,\n  namespace,\n  onError,\n  timeZone\n}) {\n  const hasMessagesError = messagesOrError instanceof IntlError;\n  function getFallbackFromErrorAndNotify(key, code, message) {\n    const error = new IntlError(code, message);\n    onError(error);\n    return getMessageFallback({\n      error,\n      key,\n      namespace\n    });\n  }\n  function translateBaseFn( /** Use a dot to indicate a level of nesting (e.g. `namespace.nestedLabel`). */\n  key, /** Key value pairs for values to interpolate into the message. */\n  values, /** Provide custom formats for numbers, dates and times. */\n  formats) {\n    if (hasMessagesError) {\n      // We have already warned about this during render\n      return getMessageFallback({\n        error: messagesOrError,\n        key,\n        namespace\n      });\n    }\n    const messages = messagesOrError;\n    let message;\n    try {\n      message = resolvePath(locale, messages, key, namespace);\n    } catch (error) {\n      return getFallbackFromErrorAndNotify(key, IntlErrorCode.MISSING_MESSAGE, error.message);\n    }\n    if (typeof message === 'object') {\n      let code, errorMessage;\n      if (Array.isArray(message)) {\n        code = IntlErrorCode.INVALID_MESSAGE;\n        {\n          errorMessage = `Message at \\`${joinPath(namespace, key)}\\` resolved to an array, but only strings are supported. See https://next-intl.dev/docs/usage/messages#arrays-of-messages`;\n        }\n      } else {\n        code = IntlErrorCode.INSUFFICIENT_PATH;\n        {\n          errorMessage = `Message at \\`${joinPath(namespace, key)}\\` resolved to an object, but only strings are supported. Use a \\`.\\` to retrieve nested messages. See https://next-intl.dev/docs/usage/messages#structuring-messages`;\n        }\n      }\n      return getFallbackFromErrorAndNotify(key, code, errorMessage);\n    }\n    let messageFormat;\n\n    // Hot path that avoids creating an `IntlMessageFormat` instance\n    const plainMessage = getPlainMessage(message, values);\n    if (plainMessage) return plainMessage;\n\n    // Lazy init the message formatter for better tree\n    // shaking in case message formatting is not used.\n    if (!formatters.getMessageFormat) {\n      formatters.getMessageFormat = createMessageFormatter(cache, formatters);\n    }\n    try {\n      messageFormat = formatters.getMessageFormat(message, locale, convertFormatsToIntlMessageFormat(globalFormats, formats, timeZone), {\n        formatters: _objectSpread(_objectSpread({}, formatters), {}, {\n          getDateTimeFormat(locales, options) {\n            // Workaround for https://github.com/formatjs/formatjs/issues/4279\n            return formatters.getDateTimeFormat(locales, _objectSpread({\n              timeZone\n            }, options));\n          }\n        })\n      });\n    } catch (error) {\n      const thrownError = error;\n      return getFallbackFromErrorAndNotify(key, IntlErrorCode.INVALID_MESSAGE, thrownError.message + ('originalMessage' in thrownError ? ` (${thrownError.originalMessage})` : ''));\n    }\n    try {\n      const formattedMessage = messageFormat.format(\n      // @ts-expect-error `intl-messageformat` expects a different format\n      // for rich text elements since a recent minor update. This\n      // needs to be evaluated in detail, possibly also in regards\n      // to be able to format to parts.\n      values ? prepareTranslationValues(values) : values);\n      if (formattedMessage == null) {\n        throw new Error(`Unable to format \\`${key}\\` in ${namespace ? `namespace \\`${namespace}\\`` : 'messages'}`);\n      }\n\n      // Limit the function signature to return strings or React elements\n      return /*#__PURE__*/ /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(formattedMessage) ||\n      // Arrays of React elements\n      Array.isArray(formattedMessage) || typeof formattedMessage === 'string' ? formattedMessage : String(formattedMessage);\n    } catch (error) {\n      return getFallbackFromErrorAndNotify(key, IntlErrorCode.FORMATTING_ERROR, error.message);\n    }\n  }\n  function translateFn( /** Use a dot to indicate a level of nesting (e.g. `namespace.nestedLabel`). */\n  key, /** Key value pairs for values to interpolate into the message. */\n  values, /** Provide custom formats for numbers, dates and times. */\n  formats) {\n    const result = translateBaseFn(key, values, formats);\n    if (typeof result !== 'string') {\n      return getFallbackFromErrorAndNotify(key, IntlErrorCode.INVALID_MESSAGE, `The message \\`${key}\\` in ${namespace ? `namespace \\`${namespace}\\`` : 'messages'} didn't resolve to a string. If you want to format rich text, use \\`t.rich\\` instead.`);\n    }\n    return result;\n  }\n  translateFn.rich = translateBaseFn;\n\n  // Augment `translateBaseFn` to return plain strings\n  translateFn.markup = (key, values, formats) => {\n    const result = translateBaseFn(key,\n    // @ts-expect-error -- `MarkupTranslationValues` is practically a sub type\n    // of `RichTranslationValues` but TypeScript isn't smart enough here.\n    values, formats);\n    if (typeof result !== 'string') {\n      const error = new IntlError(IntlErrorCode.FORMATTING_ERROR, \"`t.markup` only accepts functions for formatting that receive and return strings.\\n\\nE.g. t.markup('markup', {b: (chunks) => `<b>${chunks}</b>`})\");\n      onError(error);\n      return getMessageFallback({\n        error,\n        key,\n        namespace\n      });\n    }\n    return result;\n  };\n  translateFn.raw = key => {\n    if (hasMessagesError) {\n      // We have already warned about this during render\n      return getMessageFallback({\n        error: messagesOrError,\n        key,\n        namespace\n      });\n    }\n    const messages = messagesOrError;\n    try {\n      return resolvePath(locale, messages, key, namespace);\n    } catch (error) {\n      return getFallbackFromErrorAndNotify(key, IntlErrorCode.MISSING_MESSAGE, error.message);\n    }\n  };\n  translateFn.has = key => {\n    if (hasMessagesError) {\n      return false;\n    }\n    try {\n      resolvePath(locale, messagesOrError, key, namespace);\n      return true;\n    } catch {\n      return false;\n    }\n  };\n  return translateFn;\n}\n\n/**\n * For the strictly typed messages to work we have to wrap the namespace into\n * a mandatory prefix. See https://stackoverflow.com/a/71529575/343045\n */\nfunction resolveNamespace(namespace, namespacePrefix) {\n  return namespace === namespacePrefix ? undefined : namespace.slice((namespacePrefix + '.').length);\n}\nconst SECOND = 1;\nconst MINUTE = SECOND * 60;\nconst HOUR = MINUTE * 60;\nconst DAY = HOUR * 24;\nconst WEEK = DAY * 7;\nconst MONTH = DAY * (365 / 12); // Approximation\nconst QUARTER = MONTH * 3;\nconst YEAR = DAY * 365;\nconst UNIT_SECONDS = {\n  second: SECOND,\n  seconds: SECOND,\n  minute: MINUTE,\n  minutes: MINUTE,\n  hour: HOUR,\n  hours: HOUR,\n  day: DAY,\n  days: DAY,\n  week: WEEK,\n  weeks: WEEK,\n  month: MONTH,\n  months: MONTH,\n  quarter: QUARTER,\n  quarters: QUARTER,\n  year: YEAR,\n  years: YEAR\n};\nfunction resolveRelativeTimeUnit(seconds) {\n  const absValue = Math.abs(seconds);\n  if (absValue < MINUTE) {\n    return 'second';\n  } else if (absValue < HOUR) {\n    return 'minute';\n  } else if (absValue < DAY) {\n    return 'hour';\n  } else if (absValue < WEEK) {\n    return 'day';\n  } else if (absValue < MONTH) {\n    return 'week';\n  } else if (absValue < YEAR) {\n    return 'month';\n  }\n  return 'year';\n}\nfunction calculateRelativeTimeValue(seconds, unit) {\n  // We have to round the resulting values, as `Intl.RelativeTimeFormat`\n  // will include fractions like '2.1 hours ago'.\n  return Math.round(seconds / UNIT_SECONDS[unit]);\n}\nfunction createFormatter(props) {\n  const {\n    _cache: cache = createCache(),\n    _formatters: formatters = createIntlFormatters(cache),\n    formats,\n    locale,\n    onError = defaultOnError,\n    timeZone: globalTimeZone\n  } = props;\n  function applyTimeZone(options) {\n    if (!options?.timeZone) {\n      if (globalTimeZone) {\n        options = _objectSpread(_objectSpread({}, options), {}, {\n          timeZone: globalTimeZone\n        });\n      } else {\n        onError(new IntlError(IntlErrorCode.ENVIRONMENT_FALLBACK, `The \\`timeZone\\` parameter wasn't provided and there is no global default configured. Consider adding a global default to avoid markup mismatches caused by environment differences. Learn more: https://next-intl.dev/docs/configuration#time-zone`));\n      }\n    }\n    return options;\n  }\n  function resolveFormatOrOptions(typeFormats, formatOrOptions, overrides) {\n    let options;\n    if (typeof formatOrOptions === 'string') {\n      const formatName = formatOrOptions;\n      options = typeFormats?.[formatName];\n      if (!options) {\n        const error = new IntlError(IntlErrorCode.MISSING_FORMAT, `Format \\`${formatName}\\` is not available.`);\n        onError(error);\n        throw error;\n      }\n    } else {\n      options = formatOrOptions;\n    }\n    if (overrides) {\n      options = _objectSpread(_objectSpread({}, options), overrides);\n    }\n    return options;\n  }\n  function getFormattedValue(formatOrOptions, overrides, typeFormats, formatter, getFallback) {\n    let options;\n    try {\n      options = resolveFormatOrOptions(typeFormats, formatOrOptions, overrides);\n    } catch {\n      return getFallback();\n    }\n    try {\n      return formatter(options);\n    } catch (error) {\n      onError(new IntlError(IntlErrorCode.FORMATTING_ERROR, error.message));\n      return getFallback();\n    }\n  }\n  function dateTime(value, formatOrOptions, overrides) {\n    return getFormattedValue(formatOrOptions, overrides, formats?.dateTime, options => {\n      options = applyTimeZone(options);\n      return formatters.getDateTimeFormat(locale, options).format(value);\n    }, () => String(value));\n  }\n  function dateTimeRange(start, end, formatOrOptions, overrides) {\n    return getFormattedValue(formatOrOptions, overrides, formats?.dateTime, options => {\n      options = applyTimeZone(options);\n      return formatters.getDateTimeFormat(locale, options).formatRange(start, end);\n    }, () => [dateTime(start), dateTime(end)].join(' – '));\n  }\n  function number(value, formatOrOptions, overrides) {\n    return getFormattedValue(formatOrOptions, overrides, formats?.number, options => formatters.getNumberFormat(locale, options).format(value), () => String(value));\n  }\n  function getGlobalNow() {\n    // Only read when necessary to avoid triggering a `dynamicIO` error\n    // unnecessarily (`now` is only needed for `format.relativeTime`)\n    if (props.now) {\n      return props.now;\n    } else {\n      onError(new IntlError(IntlErrorCode.ENVIRONMENT_FALLBACK, `The \\`now\\` parameter wasn't provided to \\`relativeTime\\` and there is no global default configured, therefore the current time will be used as a fallback. See https://next-intl.dev/docs/usage/dates-times#relative-times-usenow`));\n      return new Date();\n    }\n  }\n  function relativeTime(date, nowOrOptions) {\n    try {\n      let nowDate, unit;\n      const opts = {};\n      if (nowOrOptions instanceof Date || typeof nowOrOptions === 'number') {\n        nowDate = new Date(nowOrOptions);\n      } else if (nowOrOptions) {\n        if (nowOrOptions.now != null) {\n          nowDate = new Date(nowOrOptions.now);\n        } else {\n          nowDate = getGlobalNow();\n        }\n        unit = nowOrOptions.unit;\n        opts.style = nowOrOptions.style;\n        // @ts-expect-error -- Types are slightly outdated\n        opts.numberingSystem = nowOrOptions.numberingSystem;\n      }\n      if (!nowDate) {\n        nowDate = getGlobalNow();\n      }\n      const dateDate = new Date(date);\n      const seconds = (dateDate.getTime() - nowDate.getTime()) / 1000;\n      if (!unit) {\n        unit = resolveRelativeTimeUnit(seconds);\n      }\n\n      // `numeric: 'auto'` can theoretically produce output like \"yesterday\",\n      // but it only works with integers. E.g. -1 day will produce \"yesterday\",\n      // but -1.1 days will produce \"-1.1 days\". Rounding before formatting is\n      // not desired, as the given dates might cross a threshold were the\n      // output isn't correct anymore. Example: 2024-01-08T23:00:00.000Z and\n      // 2024-01-08T01:00:00.000Z would produce \"yesterday\", which is not the\n      // case. By using `always` we can ensure correct output. The only exception\n      // is the formatting of times <1 second as \"now\".\n      opts.numeric = unit === 'second' ? 'auto' : 'always';\n      const value = calculateRelativeTimeValue(seconds, unit);\n      return formatters.getRelativeTimeFormat(locale, opts).format(value, unit);\n    } catch (error) {\n      onError(new IntlError(IntlErrorCode.FORMATTING_ERROR, error.message));\n      return String(date);\n    }\n  }\n  function list(value, formatOrOptions, overrides) {\n    const serializedValue = [];\n    const richValues = new Map();\n\n    // `formatToParts` only accepts strings, therefore we have to temporarily\n    // replace React elements with a placeholder ID that can be used to retrieve\n    // the original value afterwards.\n    let index = 0;\n    for (const item of value) {\n      let serializedItem;\n      if (typeof item === 'object') {\n        serializedItem = String(index);\n        richValues.set(serializedItem, item);\n      } else {\n        serializedItem = String(item);\n      }\n      serializedValue.push(serializedItem);\n      index++;\n    }\n    return getFormattedValue(formatOrOptions, overrides, formats?.list,\n    // @ts-expect-error -- `richValues.size` is used to determine the return type, but TypeScript can't infer the meaning of this correctly\n    options => {\n      const result = formatters.getListFormat(locale, options).formatToParts(serializedValue).map(part => part.type === 'literal' ? part.value : richValues.get(part.value) || part.value);\n      if (richValues.size > 0) {\n        return result;\n      } else {\n        return result.join('');\n      }\n    }, () => String(value));\n  }\n  return {\n    dateTime,\n    number,\n    relativeTime,\n    list,\n    dateTimeRange\n  };\n}\nfunction validateMessagesSegment(messages, invalidKeyLabels, parentPath) {\n  Object.entries(messages).forEach(([key, messageOrMessages]) => {\n    if (key.includes('.')) {\n      let keyLabel = key;\n      if (parentPath) keyLabel += ` (at ${parentPath})`;\n      invalidKeyLabels.push(keyLabel);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (messageOrMessages != null && typeof messageOrMessages === 'object') {\n      validateMessagesSegment(messageOrMessages, invalidKeyLabels, joinPath(parentPath, key));\n    }\n  });\n}\nfunction validateMessages(messages, onError) {\n  const invalidKeyLabels = [];\n  validateMessagesSegment(messages, invalidKeyLabels);\n  if (invalidKeyLabels.length > 0) {\n    onError(new IntlError(IntlErrorCode.INVALID_KEY, `Namespace keys can not contain the character \".\" as this is used to express nesting. Please remove it or replace it with another character.\n\nInvalid ${invalidKeyLabels.length === 1 ? 'key' : 'keys'}: ${invalidKeyLabels.join(', ')}\n\nIf you're migrating from a flat structure, you can convert your messages as follows:\n\nimport {set} from \"lodash\";\n\nconst input = {\n  \"one.one\": \"1.1\",\n  \"one.two\": \"1.2\",\n  \"two.one.one\": \"2.1.1\"\n};\n\nconst output = Object.entries(input).reduce(\n  (acc, [key, value]) => set(acc, key, value),\n  {}\n);\n\n// Output:\n//\n// {\n//   \"one\": {\n//     \"one\": \"1.1\",\n//     \"two\": \"1.2\"\n//   },\n//   \"two\": {\n//     \"one\": {\n//       \"one\": \"2.1.1\"\n//     }\n//   }\n// }\n`));\n  }\n}\n\n/**\n * Enhances the incoming props with defaults.\n */\nfunction initializeConfig(_ref) {\n  let {\n      formats,\n      getMessageFallback,\n      messages,\n      onError\n    } = _ref,\n    rest = _objectWithoutProperties(_ref, _excluded);\n  const finalOnError = onError || defaultOnError;\n  const finalGetMessageFallback = getMessageFallback || defaultGetMessageFallback;\n  {\n    if (messages) {\n      validateMessages(messages, finalOnError);\n    }\n  }\n  return _objectSpread(_objectSpread({}, rest), {}, {\n    formats: formats || undefined,\n    messages: messages || undefined,\n    onError: finalOnError,\n    getMessageFallback: finalGetMessageFallback\n  });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3VzZS1pbnRsL2Rpc3QvZXNtL2RldmVsb3BtZW50L2luaXRpYWxpemVDb25maWctRFBGbnZzVU8uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXVEO0FBQ0Y7QUFDUTtBQUU3RCxNQUFNSyxTQUFTLFNBQVNDLEtBQUssQ0FBQztFQUM1QkMsV0FBV0EsQ0FBQ0MsSUFBSSxFQUFFQyxlQUFlLEVBQUU7SUFDakMsSUFBSUMsT0FBTyxHQUFHRixJQUFJO0lBQ2xCLElBQUlDLGVBQWUsRUFBRTtNQUNuQkMsT0FBTyxJQUFJLElBQUksR0FBR0QsZUFBZTtJQUNuQztJQUNBLEtBQUssQ0FBQ0MsT0FBTyxDQUFDO0lBQ2QsSUFBSSxDQUFDRixJQUFJLEdBQUdBLElBQUk7SUFDaEIsSUFBSUMsZUFBZSxFQUFFO01BQ25CLElBQUksQ0FBQ0EsZUFBZSxHQUFHQSxlQUFlO0lBQ3hDO0VBQ0Y7QUFDRjtBQUVBLElBQUlFLGFBQWEsR0FBRyxhQUFhLFVBQVVBLGFBQWEsRUFBRTtFQUN4REEsYUFBYSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsaUJBQWlCO0VBQ3BEQSxhQUFhLENBQUMsZ0JBQWdCLENBQUMsR0FBRyxnQkFBZ0I7RUFDbERBLGFBQWEsQ0FBQyxzQkFBc0IsQ0FBQyxHQUFHLHNCQUFzQjtFQUM5REEsYUFBYSxDQUFDLG1CQUFtQixDQUFDLEdBQUcsbUJBQW1CO0VBQ3hEQSxhQUFhLENBQUMsaUJBQWlCLENBQUMsR0FBRyxpQkFBaUI7RUFDcERBLGFBQWEsQ0FBQyxhQUFhLENBQUMsR0FBRyxhQUFhO0VBQzVDQSxhQUFhLENBQUMsa0JBQWtCLENBQUMsR0FBRyxrQkFBa0I7RUFDdEQsT0FBT0EsYUFBYTtBQUN0QixDQUFDLENBQUNBLGFBQWEsSUFBSSxDQUFDLENBQUMsQ0FBQzs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTQyxpQ0FBaUNBLENBQUNDLGFBQWEs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S2tNLElBQUk7SUFDUHZNLE9BQU8sRUFBRUEsT0FBTyxJQUFJcUYsU0FBUztJQUM3QnJCLFFBQVEsRUFBRUEsUUFBUSxJQUFJcUIsU0FBUztJQUMvQlAsT0FBTyxFQUFFNEgsWUFBWTtJQUNyQmhILGtCQUFrQixFQUFFaUg7RUFBdUI7QUFFL0MiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQURNSU5cXE9uZURyaXZlXFxEZXNrdG9wXFxJbSBhIGJpcmRkZGRkZGRcXG5vZGVfbW9kdWxlc1xcdXNlLWludGxcXGRpc3RcXGVzbVxcZGV2ZWxvcG1lbnRcXGluaXRpYWxpemVDb25maWctRFBGbnZzVU8uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW50bE1lc3NhZ2VGb3JtYXQgfSBmcm9tICdpbnRsLW1lc3NhZ2Vmb3JtYXQnO1xuaW1wb3J0IHsgaXNWYWxpZEVsZW1lbnQsIGNsb25lRWxlbWVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IG1lbW9pemUsIHN0cmF0ZWdpZXMgfSBmcm9tICdAZm9ybWF0anMvZmFzdC1tZW1vaXplJztcblxuY2xhc3MgSW50bEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcihjb2RlLCBvcmlnaW5hbE1lc3NhZ2UpIHtcbiAgICBsZXQgbWVzc2FnZSA9IGNvZGU7XG4gICAgaWYgKG9yaWdpbmFsTWVzc2FnZSkge1xuICAgICAgbWVzc2FnZSArPSAnOiAnICsgb3JpZ2luYWxNZXNzYWdlO1xuICAgIH1cbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIGlmIChvcmlnaW5hbE1lc3NhZ2UpIHtcbiAgICAgIHRoaXMub3JpZ2luYWxNZXNzYWdlID0gb3JpZ2luYWxNZXNzYWdlO1xuICAgIH1cbiAgfVxufVxuXG52YXIgSW50bEVycm9yQ29kZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoSW50bEVycm9yQ29kZSkge1xuICBJbnRsRXJyb3JDb2RlW1wiTUlTU0lOR19NRVNTQUdFXCJdID0gXCJNSVNTSU5HX01FU1NBR0VcIjtcbiAgSW50bEVycm9yQ29kZVtcIk1JU1NJTkdfRk9STUFUXCJdID0gXCJNSVNTSU5HX0ZPUk1BVFwiO1xuICBJbnRsRXJyb3JDb2RlW1wiRU5WSVJPTk1FTlRfRkFMTEJBQ0tcIl0gPSBcIkVOVklST05NRU5UX0ZBTExCQUNLXCI7XG4gIEludGxFcnJvckNvZGVbXCJJTlNVRkZJQ0lFTlRfUEFUSFwiXSA9IFwiSU5TVUZGSUNJRU5UX1BBVEhcIjtcbiAgSW50bEVycm9yQ29kZVtcIklOVkFMSURfTUVTU0FHRVwiXSA9IFwiSU5WQUxJRF9NRVNTQUdFXCI7XG4gIEludGxFcnJvckNvZGVbXCJJTlZBTElEX0tFWVwiXSA9IFwiSU5WQUxJRF9LRVlcIjtcbiAgSW50bEVycm9yQ29kZVtcIkZPUk1BVFRJTkdfRVJST1JcIl0gPSBcIkZPUk1BVFRJTkdfRVJST1JcIjtcbiAgcmV0dXJuIEludGxFcnJvckNvZGU7XG59KEludGxFcnJvckNvZGUgfHwge30pO1xuXG4vKipcbiAqIGBpbnRsLW1lc3NhZ2Vmb3JtYXRgIHVzZXMgc2VwYXJhdGUga2V5cyBmb3IgYGRhdGVgIGFuZCBgdGltZWAsIGJ1dCB0aGVyZSdzXG4gKiBvbmx5IG9uZSBuYXRpdmUgQVBJOiBgSW50bC5EYXRlVGltZUZvcm1hdGAuIEFkZGl0aW9uYWxseSB5b3UgbWlnaHQgd2FudCB0b1xuICogaW5jbHVkZSBib3RoIGEgdGltZSBhbmQgYSBkYXRlIGluIGEgdmFsdWUsIHRoZXJlZm9yZSB0aGUgc2VwYXJhdGlvbiBkb2Vzbid0XG4gKiBzZWVtIHNvIHVzZWZ1bC4gV2Ugb2ZmZXIgYSBzaW5nbGUgYGRhdGVUaW1lYCBuYW1lc3BhY2UgaW5zdGVhZCwgYnV0IHdlIGhhdmVcbiAqIHRvIGNvbnZlcnQgdGhlIGZvcm1hdCBiZWZvcmUgYGludGwtbWVzc2FnZWZvcm1hdGAgY2FuIGJlIHVzZWQuXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRGb3JtYXRzVG9JbnRsTWVzc2FnZUZvcm1hdChnbG9iYWxGb3JtYXRzLCBpbmxpbmVGb3JtYXRzLCB0aW1lWm9uZSkge1xuICBjb25zdCBtZkRhdGVEZWZhdWx0cyA9IEludGxNZXNzYWdlRm9ybWF0LmZvcm1hdHMuZGF0ZTtcbiAgY29uc3QgbWZUaW1lRGVmYXVsdHMgPSBJbnRsTWVzc2FnZUZvcm1hdC5mb3JtYXRzLnRpbWU7XG4gIGNvbnN0IGRhdGVUaW1lRm9ybWF0cyA9IHtcbiAgICAuLi5nbG9iYWxGb3JtYXRzPy5kYXRlVGltZSxcbiAgICAuLi5pbmxpbmVGb3JtYXRzPy5kYXRlVGltZVxuICB9O1xuICBjb25zdCBhbGxGb3JtYXRzID0ge1xuICAgIGRhdGU6IHtcbiAgICAgIC4uLm1mRGF0ZURlZmF1bHRzLFxuICAgICAgLi4uZGF0ZVRpbWVGb3JtYXRzXG4gICAgfSxcbiAgICB0aW1lOiB7XG4gICAgICAuLi5tZlRpbWVEZWZhdWx0cyxcbiAgICAgIC4uLmRhdGVUaW1lRm9ybWF0c1xuICAgIH0sXG4gICAgbnVtYmVyOiB7XG4gICAgICAuLi5nbG9iYWxGb3JtYXRzPy5udW1iZXIsXG4gICAgICAuLi5pbmxpbmVGb3JtYXRzPy5udW1iZXJcbiAgICB9XG4gICAgLy8gKGxpc3QgaXMgbm90IHN1cHBvcnRlZCBpbiBJQ1UgbWVzc2FnZXMpXG4gIH07XG4gIGlmICh0aW1lWm9uZSkge1xuICAgIC8vIFRoZSBvbmx5IHdheSB0byBzZXQgYSB0aW1lIHpvbmUgd2l0aCBgaW50bC1tZXNzYWdlZm9ybWF0YCBpcyB0byBtZXJnZSBpdCBpbnRvIHRoZSBmb3JtYXRzXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zvcm1hdGpzL2Zvcm1hdGpzL2Jsb2IvODI1NmM1MjcxNTA1Y2YyNjA2ZTQ4ZTNjOTdlY2RkMTZlZGU0ZjFiNS9wYWNrYWdlcy9pbnRsL3NyYy9tZXNzYWdlLnRzI0wxNVxuICAgIFsnZGF0ZScsICd0aW1lJ10uZm9yRWFjaChwcm9wZXJ0eSA9PiB7XG4gICAgICBjb25zdCBmb3JtYXRzID0gYWxsRm9ybWF0c1twcm9wZXJ0eV07XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhmb3JtYXRzKSkge1xuICAgICAgICBmb3JtYXRzW2tleV0gPSB7XG4gICAgICAgICAgdGltZVpvbmUsXG4gICAgICAgICAgLi4udmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gYWxsRm9ybWF0cztcbn1cblxuZnVuY3Rpb24gam9pblBhdGgoLi4ucGFydHMpIHtcbiAgcmV0dXJuIHBhcnRzLmZpbHRlcihCb29sZWFuKS5qb2luKCcuJyk7XG59XG5cbi8qKlxuICogQ29udGFpbnMgZGVmYXVsdHMgdGhhdCBhcmUgdXNlZCBmb3IgYWxsIGVudHJ5IHBvaW50cyBpbnRvIHRoZSBjb3JlLlxuICogU2VlIGFsc28gYEluaXRpYWxpemVkSW50bENvbmZpZ3VyYXRpb25gLlxuICovXG5cbmZ1bmN0aW9uIGRlZmF1bHRHZXRNZXNzYWdlRmFsbGJhY2socHJvcHMpIHtcbiAgcmV0dXJuIGpvaW5QYXRoKHByb3BzLm5hbWVzcGFjZSwgcHJvcHMua2V5KTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRPbkVycm9yKGVycm9yKSB7XG4gIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDYWNoZSgpIHtcbiAgcmV0dXJuIHtcbiAgICBkYXRlVGltZToge30sXG4gICAgbnVtYmVyOiB7fSxcbiAgICBtZXNzYWdlOiB7fSxcbiAgICByZWxhdGl2ZVRpbWU6IHt9LFxuICAgIHBsdXJhbFJ1bGVzOiB7fSxcbiAgICBsaXN0OiB7fSxcbiAgICBkaXNwbGF5TmFtZXM6IHt9XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVNZW1vQ2FjaGUoc3RvcmUpIHtcbiAgcmV0dXJuIHtcbiAgICBjcmVhdGUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBnZXQoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIHN0b3JlW2tleV07XG4gICAgICAgIH0sXG4gICAgICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgc3RvcmVba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIG1lbW9GbihmbiwgY2FjaGUpIHtcbiAgcmV0dXJuIG1lbW9pemUoZm4sIHtcbiAgICBjYWNoZTogY3JlYXRlTWVtb0NhY2hlKGNhY2hlKSxcbiAgICBzdHJhdGVneTogc3RyYXRlZ2llcy52YXJpYWRpY1xuICB9KTtcbn1cbmZ1bmN0aW9uIG1lbW9Db25zdHJ1Y3RvcihDb25zdHJ1Y3RvckZuLCBjYWNoZSkge1xuICByZXR1cm4gbWVtb0ZuKCguLi5hcmdzKSA9PiBuZXcgQ29uc3RydWN0b3JGbiguLi5hcmdzKSwgY2FjaGUpO1xufVxuZnVuY3Rpb24gY3JlYXRlSW50bEZvcm1hdHRlcnMoY2FjaGUpIHtcbiAgY29uc3QgZ2V0RGF0ZVRpbWVGb3JtYXQgPSBtZW1vQ29uc3RydWN0b3IoSW50bC5EYXRlVGltZUZvcm1hdCwgY2FjaGUuZGF0ZVRpbWUpO1xuICBjb25zdCBnZXROdW1iZXJGb3JtYXQgPSBtZW1vQ29uc3RydWN0b3IoSW50bC5OdW1iZXJGb3JtYXQsIGNhY2hlLm51bWJlcik7XG4gIGNvbnN0IGdldFBsdXJhbFJ1bGVzID0gbWVtb0NvbnN0cnVjdG9yKEludGwuUGx1cmFsUnVsZXMsIGNhY2hlLnBsdXJhbFJ1bGVzKTtcbiAgY29uc3QgZ2V0UmVsYXRpdmVUaW1lRm9ybWF0ID0gbWVtb0NvbnN0cnVjdG9yKEludGwuUmVsYXRpdmVUaW1lRm9ybWF0LCBjYWNoZS5yZWxhdGl2ZVRpbWUpO1xuICBjb25zdCBnZXRMaXN0Rm9ybWF0ID0gbWVtb0NvbnN0cnVjdG9yKEludGwuTGlzdEZvcm1hdCwgY2FjaGUubGlzdCk7XG4gIGNvbnN0IGdldERpc3BsYXlOYW1lcyA9IG1lbW9Db25zdHJ1Y3RvcihJbnRsLkRpc3BsYXlOYW1lcywgY2FjaGUuZGlzcGxheU5hbWVzKTtcbiAgcmV0dXJuIHtcbiAgICBnZXREYXRlVGltZUZvcm1hdCxcbiAgICBnZXROdW1iZXJGb3JtYXQsXG4gICAgZ2V0UGx1cmFsUnVsZXMsXG4gICAgZ2V0UmVsYXRpdmVUaW1lRm9ybWF0LFxuICAgIGdldExpc3RGb3JtYXQsXG4gICAgZ2V0RGlzcGxheU5hbWVzXG4gIH07XG59XG5cbi8vIFBsYWNlZCBoZXJlIGZvciBpbXByb3ZlZCB0cmVlIHNoYWtpbmcuIFNvbWVob3cgd2hlbiB0aGlzIGlzIHBsYWNlZCBpblxuLy8gYGZvcm1hdHRlcnMudHN4YCwgdGhlbiBpdCBjYW4ndCBiZSBzaGFrZW4gb2ZmIGZyb20gYG5leHQtaW50bGAuXG5mdW5jdGlvbiBjcmVhdGVNZXNzYWdlRm9ybWF0dGVyKGNhY2hlLCBpbnRsRm9ybWF0dGVycykge1xuICBjb25zdCBnZXRNZXNzYWdlRm9ybWF0ID0gbWVtb0ZuKCguLi5hcmdzKSA9PiBuZXcgSW50bE1lc3NhZ2VGb3JtYXQoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwge1xuICAgIGZvcm1hdHRlcnM6IGludGxGb3JtYXR0ZXJzLFxuICAgIC4uLmFyZ3NbM11cbiAgfSksIGNhY2hlLm1lc3NhZ2UpO1xuICByZXR1cm4gZ2V0TWVzc2FnZUZvcm1hdDtcbn1cbmZ1bmN0aW9uIHJlc29sdmVQYXRoKGxvY2FsZSwgbWVzc2FnZXMsIGtleSwgbmFtZXNwYWNlKSB7XG4gIGNvbnN0IGZ1bGxLZXkgPSBqb2luUGF0aChuYW1lc3BhY2UsIGtleSk7XG4gIGlmICghbWVzc2FnZXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIG1lc3NhZ2VzIGF2YWlsYWJsZSBhdCBcXGAke25hbWVzcGFjZX1cXGAuYCApO1xuICB9XG4gIGxldCBtZXNzYWdlID0gbWVzc2FnZXM7XG4gIGtleS5zcGxpdCgnLicpLmZvckVhY2gocGFydCA9PiB7XG4gICAgY29uc3QgbmV4dCA9IG1lc3NhZ2VbcGFydF07XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuICAgIGlmIChwYXJ0ID09IG51bGwgfHwgbmV4dCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCByZXNvbHZlIFxcYCR7ZnVsbEtleX1cXGAgaW4gbWVzc2FnZXMgZm9yIGxvY2FsZSBcXGAke2xvY2FsZX1cXGAuYCApO1xuICAgIH1cbiAgICBtZXNzYWdlID0gbmV4dDtcbiAgfSk7XG4gIHJldHVybiBtZXNzYWdlO1xufVxuZnVuY3Rpb24gcHJlcGFyZVRyYW5zbGF0aW9uVmFsdWVzKHZhbHVlcykge1xuICAvLyBXb3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vZm9ybWF0anMvZm9ybWF0anMvaXNzdWVzLzE0NjdcbiAgY29uc3QgdHJhbnNmb3JtZWRWYWx1ZXMgPSB7fTtcbiAgT2JqZWN0LmtleXModmFsdWVzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1trZXldO1xuICAgIGxldCB0cmFuc2Zvcm1lZDtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0cmFuc2Zvcm1lZCA9IGNodW5rcyA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbHVlKGNodW5rcyk7XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovaXNWYWxpZEVsZW1lbnQocmVzdWx0KSA/IC8qI19fUFVSRV9fKi9jbG9uZUVsZW1lbnQocmVzdWx0LCB7XG4gICAgICAgICAga2V5OiBrZXkgKyBpbmRleCsrXG4gICAgICAgIH0pIDogcmVzdWx0O1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhbnNmb3JtZWQgPSB2YWx1ZTtcbiAgICB9XG4gICAgdHJhbnNmb3JtZWRWYWx1ZXNba2V5XSA9IHRyYW5zZm9ybWVkO1xuICB9KTtcbiAgcmV0dXJuIHRyYW5zZm9ybWVkVmFsdWVzO1xufVxuZnVuY3Rpb24gZ2V0TWVzc2FnZXNPckVycm9yKGxvY2FsZSwgbWVzc2FnZXMsIG5hbWVzcGFjZSwgb25FcnJvciA9IGRlZmF1bHRPbkVycm9yKSB7XG4gIHRyeSB7XG4gICAgaWYgKCFtZXNzYWdlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBtZXNzYWdlcyB3ZXJlIGNvbmZpZ3VyZWQuYCApO1xuICAgIH1cbiAgICBjb25zdCByZXRyaWV2ZWRNZXNzYWdlcyA9IG5hbWVzcGFjZSA/IHJlc29sdmVQYXRoKGxvY2FsZSwgbWVzc2FnZXMsIG5hbWVzcGFjZSkgOiBtZXNzYWdlcztcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG4gICAgaWYgKCFyZXRyaWV2ZWRNZXNzYWdlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBtZXNzYWdlcyBmb3IgbmFtZXNwYWNlIFxcYCR7bmFtZXNwYWNlfVxcYCBmb3VuZC5gICk7XG4gICAgfVxuICAgIHJldHVybiByZXRyaWV2ZWRNZXNzYWdlcztcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zdCBpbnRsRXJyb3IgPSBuZXcgSW50bEVycm9yKEludGxFcnJvckNvZGUuTUlTU0lOR19NRVNTQUdFLCBlcnJvci5tZXNzYWdlKTtcbiAgICBvbkVycm9yKGludGxFcnJvcik7XG4gICAgcmV0dXJuIGludGxFcnJvcjtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0UGxhaW5NZXNzYWdlKGNhbmRpZGF0ZSwgdmFsdWVzKSB7XG4gIC8vIFRvIGltcHJvdmUgcnVudGltZSBwZXJmb3JtYW5jZSwgb25seSBjb21waWxlIG1lc3NhZ2UgaWY6XG4gIHJldHVybiAoXG4gICAgLy8gMS4gVmFsdWVzIGFyZSBwcm92aWRlZFxuICAgIHZhbHVlcyB8fFxuICAgIC8vIDIuIFRoZXJlIGFyZSBlc2NhcGVkIGJyYWNlcyAoZS5nLiBcIid7bmFtZSd9XCIpXG4gICAgLydbe31dLy50ZXN0KGNhbmRpZGF0ZSkgfHxcbiAgICAvLyAzLiBUaGVyZSBhcmUgbWlzc2luZyBhcmd1bWVudHMgb3IgdGFncyAoZGV2LW9ubHkgZXJyb3IgaGFuZGxpbmcpXG4gICAgLzx8ey8udGVzdChjYW5kaWRhdGUpID8gdW5kZWZpbmVkIC8vIENvbXBpbGVcbiAgICA6IGNhbmRpZGF0ZSAvLyBEb24ndCBjb21waWxlXG4gICk7XG59XG5mdW5jdGlvbiBjcmVhdGVCYXNlVHJhbnNsYXRvcihjb25maWcpIHtcbiAgY29uc3QgbWVzc2FnZXNPckVycm9yID0gZ2V0TWVzc2FnZXNPckVycm9yKGNvbmZpZy5sb2NhbGUsIGNvbmZpZy5tZXNzYWdlcywgY29uZmlnLm5hbWVzcGFjZSwgY29uZmlnLm9uRXJyb3IpO1xuICByZXR1cm4gY3JlYXRlQmFzZVRyYW5zbGF0b3JJbXBsKHtcbiAgICAuLi5jb25maWcsXG4gICAgbWVzc2FnZXNPckVycm9yXG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlQmFzZVRyYW5zbGF0b3JJbXBsKHtcbiAgY2FjaGUsXG4gIGZvcm1hdHM6IGdsb2JhbEZvcm1hdHMsXG4gIGZvcm1hdHRlcnMsXG4gIGdldE1lc3NhZ2VGYWxsYmFjayA9IGRlZmF1bHRHZXRNZXNzYWdlRmFsbGJhY2ssXG4gIGxvY2FsZSxcbiAgbWVzc2FnZXNPckVycm9yLFxuICBuYW1lc3BhY2UsXG4gIG9uRXJyb3IsXG4gIHRpbWVab25lXG59KSB7XG4gIGNvbnN0IGhhc01lc3NhZ2VzRXJyb3IgPSBtZXNzYWdlc09yRXJyb3IgaW5zdGFuY2VvZiBJbnRsRXJyb3I7XG4gIGZ1bmN0aW9uIGdldEZhbGxiYWNrRnJvbUVycm9yQW5kTm90aWZ5KGtleSwgY29kZSwgbWVzc2FnZSkge1xuICAgIGNvbnN0IGVycm9yID0gbmV3IEludGxFcnJvcihjb2RlLCBtZXNzYWdlKTtcbiAgICBvbkVycm9yKGVycm9yKTtcbiAgICByZXR1cm4gZ2V0TWVzc2FnZUZhbGxiYWNrKHtcbiAgICAgIGVycm9yLFxuICAgICAga2V5LFxuICAgICAgbmFtZXNwYWNlXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gdHJhbnNsYXRlQmFzZUZuKC8qKiBVc2UgYSBkb3QgdG8gaW5kaWNhdGUgYSBsZXZlbCBvZiBuZXN0aW5nIChlLmcuIGBuYW1lc3BhY2UubmVzdGVkTGFiZWxgKS4gKi9cbiAga2V5LCAvKiogS2V5IHZhbHVlIHBhaXJzIGZvciB2YWx1ZXMgdG8gaW50ZXJwb2xhdGUgaW50byB0aGUgbWVzc2FnZS4gKi9cbiAgdmFsdWVzLCAvKiogUHJvdmlkZSBjdXN0b20gZm9ybWF0cyBmb3IgbnVtYmVycywgZGF0ZXMgYW5kIHRpbWVzLiAqL1xuICBmb3JtYXRzKSB7XG4gICAgaWYgKGhhc01lc3NhZ2VzRXJyb3IpIHtcbiAgICAgIC8vIFdlIGhhdmUgYWxyZWFkeSB3YXJuZWQgYWJvdXQgdGhpcyBkdXJpbmcgcmVuZGVyXG4gICAgICByZXR1cm4gZ2V0TWVzc2FnZUZhbGxiYWNrKHtcbiAgICAgICAgZXJyb3I6IG1lc3NhZ2VzT3JFcnJvcixcbiAgICAgICAga2V5LFxuICAgICAgICBuYW1lc3BhY2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlcyA9IG1lc3NhZ2VzT3JFcnJvcjtcbiAgICBsZXQgbWVzc2FnZTtcbiAgICB0cnkge1xuICAgICAgbWVzc2FnZSA9IHJlc29sdmVQYXRoKGxvY2FsZSwgbWVzc2FnZXMsIGtleSwgbmFtZXNwYWNlKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIGdldEZhbGxiYWNrRnJvbUVycm9yQW5kTm90aWZ5KGtleSwgSW50bEVycm9yQ29kZS5NSVNTSU5HX01FU1NBR0UsIGVycm9yLm1lc3NhZ2UpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdvYmplY3QnKSB7XG4gICAgICBsZXQgY29kZSwgZXJyb3JNZXNzYWdlO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWVzc2FnZSkpIHtcbiAgICAgICAgY29kZSA9IEludGxFcnJvckNvZGUuSU5WQUxJRF9NRVNTQUdFO1xuICAgICAgICB7XG4gICAgICAgICAgZXJyb3JNZXNzYWdlID0gYE1lc3NhZ2UgYXQgXFxgJHtqb2luUGF0aChuYW1lc3BhY2UsIGtleSl9XFxgIHJlc29sdmVkIHRvIGFuIGFycmF5LCBidXQgb25seSBzdHJpbmdzIGFyZSBzdXBwb3J0ZWQuIFNlZSBodHRwczovL25leHQtaW50bC5kZXYvZG9jcy91c2FnZS9tZXNzYWdlcyNhcnJheXMtb2YtbWVzc2FnZXNgO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb2RlID0gSW50bEVycm9yQ29kZS5JTlNVRkZJQ0lFTlRfUEFUSDtcbiAgICAgICAge1xuICAgICAgICAgIGVycm9yTWVzc2FnZSA9IGBNZXNzYWdlIGF0IFxcYCR7am9pblBhdGgobmFtZXNwYWNlLCBrZXkpfVxcYCByZXNvbHZlZCB0byBhbiBvYmplY3QsIGJ1dCBvbmx5IHN0cmluZ3MgYXJlIHN1cHBvcnRlZC4gVXNlIGEgXFxgLlxcYCB0byByZXRyaWV2ZSBuZXN0ZWQgbWVzc2FnZXMuIFNlZSBodHRwczovL25leHQtaW50bC5kZXYvZG9jcy91c2FnZS9tZXNzYWdlcyNzdHJ1Y3R1cmluZy1tZXNzYWdlc2A7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRGYWxsYmFja0Zyb21FcnJvckFuZE5vdGlmeShrZXksIGNvZGUsIGVycm9yTWVzc2FnZSk7XG4gICAgfVxuICAgIGxldCBtZXNzYWdlRm9ybWF0O1xuXG4gICAgLy8gSG90IHBhdGggdGhhdCBhdm9pZHMgY3JlYXRpbmcgYW4gYEludGxNZXNzYWdlRm9ybWF0YCBpbnN0YW5jZVxuICAgIGNvbnN0IHBsYWluTWVzc2FnZSA9IGdldFBsYWluTWVzc2FnZShtZXNzYWdlLCB2YWx1ZXMpO1xuICAgIGlmIChwbGFpbk1lc3NhZ2UpIHJldHVybiBwbGFpbk1lc3NhZ2U7XG5cbiAgICAvLyBMYXp5IGluaXQgdGhlIG1lc3NhZ2UgZm9ybWF0dGVyIGZvciBiZXR0ZXIgdHJlZVxuICAgIC8vIHNoYWtpbmcgaW4gY2FzZSBtZXNzYWdlIGZvcm1hdHRpbmcgaXMgbm90IHVzZWQuXG4gICAgaWYgKCFmb3JtYXR0ZXJzLmdldE1lc3NhZ2VGb3JtYXQpIHtcbiAgICAgIGZvcm1hdHRlcnMuZ2V0TWVzc2FnZUZvcm1hdCA9IGNyZWF0ZU1lc3NhZ2VGb3JtYXR0ZXIoY2FjaGUsIGZvcm1hdHRlcnMpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgbWVzc2FnZUZvcm1hdCA9IGZvcm1hdHRlcnMuZ2V0TWVzc2FnZUZvcm1hdChtZXNzYWdlLCBsb2NhbGUsIGNvbnZlcnRGb3JtYXRzVG9JbnRsTWVzc2FnZUZvcm1hdChnbG9iYWxGb3JtYXRzLCBmb3JtYXRzLCB0aW1lWm9uZSksIHtcbiAgICAgICAgZm9ybWF0dGVyczoge1xuICAgICAgICAgIC4uLmZvcm1hdHRlcnMsXG4gICAgICAgICAgZ2V0RGF0ZVRpbWVGb3JtYXQobG9jYWxlcywgb3B0aW9ucykge1xuICAgICAgICAgICAgLy8gV29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL2Zvcm1hdGpzL2Zvcm1hdGpzL2lzc3Vlcy80Mjc5XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0dGVycy5nZXREYXRlVGltZUZvcm1hdChsb2NhbGVzLCB7XG4gICAgICAgICAgICAgIHRpbWVab25lLFxuICAgICAgICAgICAgICAuLi5vcHRpb25zXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zdCB0aHJvd25FcnJvciA9IGVycm9yO1xuICAgICAgcmV0dXJuIGdldEZhbGxiYWNrRnJvbUVycm9yQW5kTm90aWZ5KGtleSwgSW50bEVycm9yQ29kZS5JTlZBTElEX01FU1NBR0UsIHRocm93bkVycm9yLm1lc3NhZ2UgKyAoJ29yaWdpbmFsTWVzc2FnZScgaW4gdGhyb3duRXJyb3IgPyBgICgke3Rocm93bkVycm9yLm9yaWdpbmFsTWVzc2FnZX0pYCA6ICcnKSApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgZm9ybWF0dGVkTWVzc2FnZSA9IG1lc3NhZ2VGb3JtYXQuZm9ybWF0KFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBgaW50bC1tZXNzYWdlZm9ybWF0YCBleHBlY3RzIGEgZGlmZmVyZW50IGZvcm1hdFxuICAgICAgLy8gZm9yIHJpY2ggdGV4dCBlbGVtZW50cyBzaW5jZSBhIHJlY2VudCBtaW5vciB1cGRhdGUuIFRoaXNcbiAgICAgIC8vIG5lZWRzIHRvIGJlIGV2YWx1YXRlZCBpbiBkZXRhaWwsIHBvc3NpYmx5IGFsc28gaW4gcmVnYXJkc1xuICAgICAgLy8gdG8gYmUgYWJsZSB0byBmb3JtYXQgdG8gcGFydHMuXG4gICAgICB2YWx1ZXMgPyBwcmVwYXJlVHJhbnNsYXRpb25WYWx1ZXModmFsdWVzKSA6IHZhbHVlcyk7XG4gICAgICBpZiAoZm9ybWF0dGVkTWVzc2FnZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGZvcm1hdCBcXGAke2tleX1cXGAgaW4gJHtuYW1lc3BhY2UgPyBgbmFtZXNwYWNlIFxcYCR7bmFtZXNwYWNlfVxcYGAgOiAnbWVzc2FnZXMnfWAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gTGltaXQgdGhlIGZ1bmN0aW9uIHNpZ25hdHVyZSB0byByZXR1cm4gc3RyaW5ncyBvciBSZWFjdCBlbGVtZW50c1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9pc1ZhbGlkRWxlbWVudChmb3JtYXR0ZWRNZXNzYWdlKSB8fFxuICAgICAgLy8gQXJyYXlzIG9mIFJlYWN0IGVsZW1lbnRzXG4gICAgICBBcnJheS5pc0FycmF5KGZvcm1hdHRlZE1lc3NhZ2UpIHx8IHR5cGVvZiBmb3JtYXR0ZWRNZXNzYWdlID09PSAnc3RyaW5nJyA/IGZvcm1hdHRlZE1lc3NhZ2UgOiBTdHJpbmcoZm9ybWF0dGVkTWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBnZXRGYWxsYmFja0Zyb21FcnJvckFuZE5vdGlmeShrZXksIEludGxFcnJvckNvZGUuRk9STUFUVElOR19FUlJPUiwgZXJyb3IubWVzc2FnZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHRyYW5zbGF0ZUZuKC8qKiBVc2UgYSBkb3QgdG8gaW5kaWNhdGUgYSBsZXZlbCBvZiBuZXN0aW5nIChlLmcuIGBuYW1lc3BhY2UubmVzdGVkTGFiZWxgKS4gKi9cbiAga2V5LCAvKiogS2V5IHZhbHVlIHBhaXJzIGZvciB2YWx1ZXMgdG8gaW50ZXJwb2xhdGUgaW50byB0aGUgbWVzc2FnZS4gKi9cbiAgdmFsdWVzLCAvKiogUHJvdmlkZSBjdXN0b20gZm9ybWF0cyBmb3IgbnVtYmVycywgZGF0ZXMgYW5kIHRpbWVzLiAqL1xuICBmb3JtYXRzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdHJhbnNsYXRlQmFzZUZuKGtleSwgdmFsdWVzLCBmb3JtYXRzKTtcbiAgICBpZiAodHlwZW9mIHJlc3VsdCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBnZXRGYWxsYmFja0Zyb21FcnJvckFuZE5vdGlmeShrZXksIEludGxFcnJvckNvZGUuSU5WQUxJRF9NRVNTQUdFLCBgVGhlIG1lc3NhZ2UgXFxgJHtrZXl9XFxgIGluICR7bmFtZXNwYWNlID8gYG5hbWVzcGFjZSBcXGAke25hbWVzcGFjZX1cXGBgIDogJ21lc3NhZ2VzJ30gZGlkbid0IHJlc29sdmUgdG8gYSBzdHJpbmcuIElmIHlvdSB3YW50IHRvIGZvcm1hdCByaWNoIHRleHQsIHVzZSBcXGB0LnJpY2hcXGAgaW5zdGVhZC5gICk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgdHJhbnNsYXRlRm4ucmljaCA9IHRyYW5zbGF0ZUJhc2VGbjtcblxuICAvLyBBdWdtZW50IGB0cmFuc2xhdGVCYXNlRm5gIHRvIHJldHVybiBwbGFpbiBzdHJpbmdzXG4gIHRyYW5zbGF0ZUZuLm1hcmt1cCA9IChrZXksIHZhbHVlcywgZm9ybWF0cykgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRyYW5zbGF0ZUJhc2VGbihrZXksXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtLSBgTWFya3VwVHJhbnNsYXRpb25WYWx1ZXNgIGlzIHByYWN0aWNhbGx5IGEgc3ViIHR5cGVcbiAgICAvLyBvZiBgUmljaFRyYW5zbGF0aW9uVmFsdWVzYCBidXQgVHlwZVNjcmlwdCBpc24ndCBzbWFydCBlbm91Z2ggaGVyZS5cbiAgICB2YWx1ZXMsIGZvcm1hdHMpO1xuICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgSW50bEVycm9yKEludGxFcnJvckNvZGUuRk9STUFUVElOR19FUlJPUiwgXCJgdC5tYXJrdXBgIG9ubHkgYWNjZXB0cyBmdW5jdGlvbnMgZm9yIGZvcm1hdHRpbmcgdGhhdCByZWNlaXZlIGFuZCByZXR1cm4gc3RyaW5ncy5cXG5cXG5FLmcuIHQubWFya3VwKCdtYXJrdXAnLCB7YjogKGNodW5rcykgPT4gYDxiPiR7Y2h1bmtzfTwvYj5gfSlcIik7XG4gICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgIHJldHVybiBnZXRNZXNzYWdlRmFsbGJhY2soe1xuICAgICAgICBlcnJvcixcbiAgICAgICAga2V5LFxuICAgICAgICBuYW1lc3BhY2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICB0cmFuc2xhdGVGbi5yYXcgPSBrZXkgPT4ge1xuICAgIGlmIChoYXNNZXNzYWdlc0Vycm9yKSB7XG4gICAgICAvLyBXZSBoYXZlIGFscmVhZHkgd2FybmVkIGFib3V0IHRoaXMgZHVyaW5nIHJlbmRlclxuICAgICAgcmV0dXJuIGdldE1lc3NhZ2VGYWxsYmFjayh7XG4gICAgICAgIGVycm9yOiBtZXNzYWdlc09yRXJyb3IsXG4gICAgICAgIGtleSxcbiAgICAgICAgbmFtZXNwYWNlXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZXMgPSBtZXNzYWdlc09yRXJyb3I7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiByZXNvbHZlUGF0aChsb2NhbGUsIG1lc3NhZ2VzLCBrZXksIG5hbWVzcGFjZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBnZXRGYWxsYmFja0Zyb21FcnJvckFuZE5vdGlmeShrZXksIEludGxFcnJvckNvZGUuTUlTU0lOR19NRVNTQUdFLCBlcnJvci5tZXNzYWdlKTtcbiAgICB9XG4gIH07XG4gIHRyYW5zbGF0ZUZuLmhhcyA9IGtleSA9PiB7XG4gICAgaWYgKGhhc01lc3NhZ2VzRXJyb3IpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJlc29sdmVQYXRoKGxvY2FsZSwgbWVzc2FnZXNPckVycm9yLCBrZXksIG5hbWVzcGFjZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG4gIHJldHVybiB0cmFuc2xhdGVGbjtcbn1cblxuLyoqXG4gKiBGb3IgdGhlIHN0cmljdGx5IHR5cGVkIG1lc3NhZ2VzIHRvIHdvcmsgd2UgaGF2ZSB0byB3cmFwIHRoZSBuYW1lc3BhY2UgaW50b1xuICogYSBtYW5kYXRvcnkgcHJlZml4LiBTZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzcxNTI5NTc1LzM0MzA0NVxuICovXG5mdW5jdGlvbiByZXNvbHZlTmFtZXNwYWNlKG5hbWVzcGFjZSwgbmFtZXNwYWNlUHJlZml4KSB7XG4gIHJldHVybiBuYW1lc3BhY2UgPT09IG5hbWVzcGFjZVByZWZpeCA/IHVuZGVmaW5lZCA6IG5hbWVzcGFjZS5zbGljZSgobmFtZXNwYWNlUHJlZml4ICsgJy4nKS5sZW5ndGgpO1xufVxuXG5jb25zdCBTRUNPTkQgPSAxO1xuY29uc3QgTUlOVVRFID0gU0VDT05EICogNjA7XG5jb25zdCBIT1VSID0gTUlOVVRFICogNjA7XG5jb25zdCBEQVkgPSBIT1VSICogMjQ7XG5jb25zdCBXRUVLID0gREFZICogNztcbmNvbnN0IE1PTlRIID0gREFZICogKDM2NSAvIDEyKTsgLy8gQXBwcm94aW1hdGlvblxuY29uc3QgUVVBUlRFUiA9IE1PTlRIICogMztcbmNvbnN0IFlFQVIgPSBEQVkgKiAzNjU7XG5jb25zdCBVTklUX1NFQ09ORFMgPSB7XG4gIHNlY29uZDogU0VDT05ELFxuICBzZWNvbmRzOiBTRUNPTkQsXG4gIG1pbnV0ZTogTUlOVVRFLFxuICBtaW51dGVzOiBNSU5VVEUsXG4gIGhvdXI6IEhPVVIsXG4gIGhvdXJzOiBIT1VSLFxuICBkYXk6IERBWSxcbiAgZGF5czogREFZLFxuICB3ZWVrOiBXRUVLLFxuICB3ZWVrczogV0VFSyxcbiAgbW9udGg6IE1PTlRILFxuICBtb250aHM6IE1PTlRILFxuICBxdWFydGVyOiBRVUFSVEVSLFxuICBxdWFydGVyczogUVVBUlRFUixcbiAgeWVhcjogWUVBUixcbiAgeWVhcnM6IFlFQVJcbn07XG5mdW5jdGlvbiByZXNvbHZlUmVsYXRpdmVUaW1lVW5pdChzZWNvbmRzKSB7XG4gIGNvbnN0IGFic1ZhbHVlID0gTWF0aC5hYnMoc2Vjb25kcyk7XG4gIGlmIChhYnNWYWx1ZSA8IE1JTlVURSkge1xuICAgIHJldHVybiAnc2Vjb25kJztcbiAgfSBlbHNlIGlmIChhYnNWYWx1ZSA8IEhPVVIpIHtcbiAgICByZXR1cm4gJ21pbnV0ZSc7XG4gIH0gZWxzZSBpZiAoYWJzVmFsdWUgPCBEQVkpIHtcbiAgICByZXR1cm4gJ2hvdXInO1xuICB9IGVsc2UgaWYgKGFic1ZhbHVlIDwgV0VFSykge1xuICAgIHJldHVybiAnZGF5JztcbiAgfSBlbHNlIGlmIChhYnNWYWx1ZSA8IE1PTlRIKSB7XG4gICAgcmV0dXJuICd3ZWVrJztcbiAgfSBlbHNlIGlmIChhYnNWYWx1ZSA8IFlFQVIpIHtcbiAgICByZXR1cm4gJ21vbnRoJztcbiAgfVxuICByZXR1cm4gJ3llYXInO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlUmVsYXRpdmVUaW1lVmFsdWUoc2Vjb25kcywgdW5pdCkge1xuICAvLyBXZSBoYXZlIHRvIHJvdW5kIHRoZSByZXN1bHRpbmcgdmFsdWVzLCBhcyBgSW50bC5SZWxhdGl2ZVRpbWVGb3JtYXRgXG4gIC8vIHdpbGwgaW5jbHVkZSBmcmFjdGlvbnMgbGlrZSAnMi4xIGhvdXJzIGFnbycuXG4gIHJldHVybiBNYXRoLnJvdW5kKHNlY29uZHMgLyBVTklUX1NFQ09ORFNbdW5pdF0pO1xufVxuZnVuY3Rpb24gY3JlYXRlRm9ybWF0dGVyKHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBfY2FjaGU6IGNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcbiAgICBfZm9ybWF0dGVyczogZm9ybWF0dGVycyA9IGNyZWF0ZUludGxGb3JtYXR0ZXJzKGNhY2hlKSxcbiAgICBmb3JtYXRzLFxuICAgIGxvY2FsZSxcbiAgICBvbkVycm9yID0gZGVmYXVsdE9uRXJyb3IsXG4gICAgdGltZVpvbmU6IGdsb2JhbFRpbWVab25lXG4gIH0gPSBwcm9wcztcbiAgZnVuY3Rpb24gYXBwbHlUaW1lWm9uZShvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zPy50aW1lWm9uZSkge1xuICAgICAgaWYgKGdsb2JhbFRpbWVab25lKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICB0aW1lWm9uZTogZ2xvYmFsVGltZVpvbmVcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uRXJyb3IobmV3IEludGxFcnJvcihJbnRsRXJyb3JDb2RlLkVOVklST05NRU5UX0ZBTExCQUNLLCBgVGhlIFxcYHRpbWVab25lXFxgIHBhcmFtZXRlciB3YXNuJ3QgcHJvdmlkZWQgYW5kIHRoZXJlIGlzIG5vIGdsb2JhbCBkZWZhdWx0IGNvbmZpZ3VyZWQuIENvbnNpZGVyIGFkZGluZyBhIGdsb2JhbCBkZWZhdWx0IHRvIGF2b2lkIG1hcmt1cCBtaXNtYXRjaGVzIGNhdXNlZCBieSBlbnZpcm9ubWVudCBkaWZmZXJlbmNlcy4gTGVhcm4gbW9yZTogaHR0cHM6Ly9uZXh0LWludGwuZGV2L2RvY3MvY29uZmlndXJhdGlvbiN0aW1lLXpvbmVgICkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfVxuICBmdW5jdGlvbiByZXNvbHZlRm9ybWF0T3JPcHRpb25zKHR5cGVGb3JtYXRzLCBmb3JtYXRPck9wdGlvbnMsIG92ZXJyaWRlcykge1xuICAgIGxldCBvcHRpb25zO1xuICAgIGlmICh0eXBlb2YgZm9ybWF0T3JPcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgZm9ybWF0TmFtZSA9IGZvcm1hdE9yT3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSB0eXBlRm9ybWF0cz8uW2Zvcm1hdE5hbWVdO1xuICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEludGxFcnJvcihJbnRsRXJyb3JDb2RlLk1JU1NJTkdfRk9STUFULCBgRm9ybWF0IFxcYCR7Zm9ybWF0TmFtZX1cXGAgaXMgbm90IGF2YWlsYWJsZS5gICk7XG4gICAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucyA9IGZvcm1hdE9yT3B0aW9ucztcbiAgICB9XG4gICAgaWYgKG92ZXJyaWRlcykge1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgLi4ub3ZlcnJpZGVzXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfVxuICBmdW5jdGlvbiBnZXRGb3JtYXR0ZWRWYWx1ZShmb3JtYXRPck9wdGlvbnMsIG92ZXJyaWRlcywgdHlwZUZvcm1hdHMsIGZvcm1hdHRlciwgZ2V0RmFsbGJhY2spIHtcbiAgICBsZXQgb3B0aW9ucztcbiAgICB0cnkge1xuICAgICAgb3B0aW9ucyA9IHJlc29sdmVGb3JtYXRPck9wdGlvbnModHlwZUZvcm1hdHMsIGZvcm1hdE9yT3B0aW9ucywgb3ZlcnJpZGVzKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBnZXRGYWxsYmFjaygpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZvcm1hdHRlcihvcHRpb25zKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgb25FcnJvcihuZXcgSW50bEVycm9yKEludGxFcnJvckNvZGUuRk9STUFUVElOR19FUlJPUiwgZXJyb3IubWVzc2FnZSkpO1xuICAgICAgcmV0dXJuIGdldEZhbGxiYWNrKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGRhdGVUaW1lKHZhbHVlLCBmb3JtYXRPck9wdGlvbnMsIG92ZXJyaWRlcykge1xuICAgIHJldHVybiBnZXRGb3JtYXR0ZWRWYWx1ZShmb3JtYXRPck9wdGlvbnMsIG92ZXJyaWRlcywgZm9ybWF0cz8uZGF0ZVRpbWUsIG9wdGlvbnMgPT4ge1xuICAgICAgb3B0aW9ucyA9IGFwcGx5VGltZVpvbmUob3B0aW9ucyk7XG4gICAgICByZXR1cm4gZm9ybWF0dGVycy5nZXREYXRlVGltZUZvcm1hdChsb2NhbGUsIG9wdGlvbnMpLmZvcm1hdCh2YWx1ZSk7XG4gICAgfSwgKCkgPT4gU3RyaW5nKHZhbHVlKSk7XG4gIH1cbiAgZnVuY3Rpb24gZGF0ZVRpbWVSYW5nZShzdGFydCwgZW5kLCBmb3JtYXRPck9wdGlvbnMsIG92ZXJyaWRlcykge1xuICAgIHJldHVybiBnZXRGb3JtYXR0ZWRWYWx1ZShmb3JtYXRPck9wdGlvbnMsIG92ZXJyaWRlcywgZm9ybWF0cz8uZGF0ZVRpbWUsIG9wdGlvbnMgPT4ge1xuICAgICAgb3B0aW9ucyA9IGFwcGx5VGltZVpvbmUob3B0aW9ucyk7XG4gICAgICByZXR1cm4gZm9ybWF0dGVycy5nZXREYXRlVGltZUZvcm1hdChsb2NhbGUsIG9wdGlvbnMpLmZvcm1hdFJhbmdlKHN0YXJ0LCBlbmQpO1xuICAgIH0sICgpID0+IFtkYXRlVGltZShzdGFydCksIGRhdGVUaW1lKGVuZCldLmpvaW4oJ+KAieKAk+KAiScpKTtcbiAgfVxuICBmdW5jdGlvbiBudW1iZXIodmFsdWUsIGZvcm1hdE9yT3B0aW9ucywgb3ZlcnJpZGVzKSB7XG4gICAgcmV0dXJuIGdldEZvcm1hdHRlZFZhbHVlKGZvcm1hdE9yT3B0aW9ucywgb3ZlcnJpZGVzLCBmb3JtYXRzPy5udW1iZXIsIG9wdGlvbnMgPT4gZm9ybWF0dGVycy5nZXROdW1iZXJGb3JtYXQobG9jYWxlLCBvcHRpb25zKS5mb3JtYXQodmFsdWUpLCAoKSA9PiBTdHJpbmcodmFsdWUpKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRHbG9iYWxOb3coKSB7XG4gICAgLy8gT25seSByZWFkIHdoZW4gbmVjZXNzYXJ5IHRvIGF2b2lkIHRyaWdnZXJpbmcgYSBgZHluYW1pY0lPYCBlcnJvclxuICAgIC8vIHVubmVjZXNzYXJpbHkgKGBub3dgIGlzIG9ubHkgbmVlZGVkIGZvciBgZm9ybWF0LnJlbGF0aXZlVGltZWApXG4gICAgaWYgKHByb3BzLm5vdykge1xuICAgICAgcmV0dXJuIHByb3BzLm5vdztcbiAgICB9IGVsc2Uge1xuICAgICAgb25FcnJvcihuZXcgSW50bEVycm9yKEludGxFcnJvckNvZGUuRU5WSVJPTk1FTlRfRkFMTEJBQ0ssIGBUaGUgXFxgbm93XFxgIHBhcmFtZXRlciB3YXNuJ3QgcHJvdmlkZWQgdG8gXFxgcmVsYXRpdmVUaW1lXFxgIGFuZCB0aGVyZSBpcyBubyBnbG9iYWwgZGVmYXVsdCBjb25maWd1cmVkLCB0aGVyZWZvcmUgdGhlIGN1cnJlbnQgdGltZSB3aWxsIGJlIHVzZWQgYXMgYSBmYWxsYmFjay4gU2VlIGh0dHBzOi8vbmV4dC1pbnRsLmRldi9kb2NzL3VzYWdlL2RhdGVzLXRpbWVzI3JlbGF0aXZlLXRpbWVzLXVzZW5vd2AgKSk7XG4gICAgICByZXR1cm4gbmV3IERhdGUoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcmVsYXRpdmVUaW1lKGRhdGUsIG5vd09yT3B0aW9ucykge1xuICAgIHRyeSB7XG4gICAgICBsZXQgbm93RGF0ZSwgdW5pdDtcbiAgICAgIGNvbnN0IG9wdHMgPSB7fTtcbiAgICAgIGlmIChub3dPck9wdGlvbnMgaW5zdGFuY2VvZiBEYXRlIHx8IHR5cGVvZiBub3dPck9wdGlvbnMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIG5vd0RhdGUgPSBuZXcgRGF0ZShub3dPck9wdGlvbnMpO1xuICAgICAgfSBlbHNlIGlmIChub3dPck9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG5vd09yT3B0aW9ucy5ub3cgIT0gbnVsbCkge1xuICAgICAgICAgIG5vd0RhdGUgPSBuZXcgRGF0ZShub3dPck9wdGlvbnMubm93KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub3dEYXRlID0gZ2V0R2xvYmFsTm93KCk7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdCA9IG5vd09yT3B0aW9ucy51bml0O1xuICAgICAgICBvcHRzLnN0eWxlID0gbm93T3JPcHRpb25zLnN0eWxlO1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0tIFR5cGVzIGFyZSBzbGlnaHRseSBvdXRkYXRlZFxuICAgICAgICBvcHRzLm51bWJlcmluZ1N5c3RlbSA9IG5vd09yT3B0aW9ucy5udW1iZXJpbmdTeXN0ZW07XG4gICAgICB9XG4gICAgICBpZiAoIW5vd0RhdGUpIHtcbiAgICAgICAgbm93RGF0ZSA9IGdldEdsb2JhbE5vdygpO1xuICAgICAgfVxuICAgICAgY29uc3QgZGF0ZURhdGUgPSBuZXcgRGF0ZShkYXRlKTtcbiAgICAgIGNvbnN0IHNlY29uZHMgPSAoZGF0ZURhdGUuZ2V0VGltZSgpIC0gbm93RGF0ZS5nZXRUaW1lKCkpIC8gMTAwMDtcbiAgICAgIGlmICghdW5pdCkge1xuICAgICAgICB1bml0ID0gcmVzb2x2ZVJlbGF0aXZlVGltZVVuaXQoc2Vjb25kcyk7XG4gICAgICB9XG5cbiAgICAgIC8vIGBudW1lcmljOiAnYXV0bydgIGNhbiB0aGVvcmV0aWNhbGx5IHByb2R1Y2Ugb3V0cHV0IGxpa2UgXCJ5ZXN0ZXJkYXlcIixcbiAgICAgIC8vIGJ1dCBpdCBvbmx5IHdvcmtzIHdpdGggaW50ZWdlcnMuIEUuZy4gLTEgZGF5IHdpbGwgcHJvZHVjZSBcInllc3RlcmRheVwiLFxuICAgICAgLy8gYnV0IC0xLjEgZGF5cyB3aWxsIHByb2R1Y2UgXCItMS4xIGRheXNcIi4gUm91bmRpbmcgYmVmb3JlIGZvcm1hdHRpbmcgaXNcbiAgICAgIC8vIG5vdCBkZXNpcmVkLCBhcyB0aGUgZ2l2ZW4gZGF0ZXMgbWlnaHQgY3Jvc3MgYSB0aHJlc2hvbGQgd2VyZSB0aGVcbiAgICAgIC8vIG91dHB1dCBpc24ndCBjb3JyZWN0IGFueW1vcmUuIEV4YW1wbGU6IDIwMjQtMDEtMDhUMjM6MDA6MDAuMDAwWiBhbmRcbiAgICAgIC8vIDIwMjQtMDEtMDhUMDE6MDA6MDAuMDAwWiB3b3VsZCBwcm9kdWNlIFwieWVzdGVyZGF5XCIsIHdoaWNoIGlzIG5vdCB0aGVcbiAgICAgIC8vIGNhc2UuIEJ5IHVzaW5nIGBhbHdheXNgIHdlIGNhbiBlbnN1cmUgY29ycmVjdCBvdXRwdXQuIFRoZSBvbmx5IGV4Y2VwdGlvblxuICAgICAgLy8gaXMgdGhlIGZvcm1hdHRpbmcgb2YgdGltZXMgPDEgc2Vjb25kIGFzIFwibm93XCIuXG4gICAgICBvcHRzLm51bWVyaWMgPSB1bml0ID09PSAnc2Vjb25kJyA/ICdhdXRvJyA6ICdhbHdheXMnO1xuICAgICAgY29uc3QgdmFsdWUgPSBjYWxjdWxhdGVSZWxhdGl2ZVRpbWVWYWx1ZShzZWNvbmRzLCB1bml0KTtcbiAgICAgIHJldHVybiBmb3JtYXR0ZXJzLmdldFJlbGF0aXZlVGltZUZvcm1hdChsb2NhbGUsIG9wdHMpLmZvcm1hdCh2YWx1ZSwgdW5pdCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIG9uRXJyb3IobmV3IEludGxFcnJvcihJbnRsRXJyb3JDb2RlLkZPUk1BVFRJTkdfRVJST1IsIGVycm9yLm1lc3NhZ2UpKTtcbiAgICAgIHJldHVybiBTdHJpbmcoZGF0ZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGxpc3QodmFsdWUsIGZvcm1hdE9yT3B0aW9ucywgb3ZlcnJpZGVzKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZFZhbHVlID0gW107XG4gICAgY29uc3QgcmljaFZhbHVlcyA9IG5ldyBNYXAoKTtcblxuICAgIC8vIGBmb3JtYXRUb1BhcnRzYCBvbmx5IGFjY2VwdHMgc3RyaW5ncywgdGhlcmVmb3JlIHdlIGhhdmUgdG8gdGVtcG9yYXJpbHlcbiAgICAvLyByZXBsYWNlIFJlYWN0IGVsZW1lbnRzIHdpdGggYSBwbGFjZWhvbGRlciBJRCB0aGF0IGNhbiBiZSB1c2VkIHRvIHJldHJpZXZlXG4gICAgLy8gdGhlIG9yaWdpbmFsIHZhbHVlIGFmdGVyd2FyZHMuXG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdmFsdWUpIHtcbiAgICAgIGxldCBzZXJpYWxpemVkSXRlbTtcbiAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgc2VyaWFsaXplZEl0ZW0gPSBTdHJpbmcoaW5kZXgpO1xuICAgICAgICByaWNoVmFsdWVzLnNldChzZXJpYWxpemVkSXRlbSwgaXRlbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXJpYWxpemVkSXRlbSA9IFN0cmluZyhpdGVtKTtcbiAgICAgIH1cbiAgICAgIHNlcmlhbGl6ZWRWYWx1ZS5wdXNoKHNlcmlhbGl6ZWRJdGVtKTtcbiAgICAgIGluZGV4Kys7XG4gICAgfVxuICAgIHJldHVybiBnZXRGb3JtYXR0ZWRWYWx1ZShmb3JtYXRPck9wdGlvbnMsIG92ZXJyaWRlcywgZm9ybWF0cz8ubGlzdCxcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0tIGByaWNoVmFsdWVzLnNpemVgIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSByZXR1cm4gdHlwZSwgYnV0IFR5cGVTY3JpcHQgY2FuJ3QgaW5mZXIgdGhlIG1lYW5pbmcgb2YgdGhpcyBjb3JyZWN0bHlcbiAgICBvcHRpb25zID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGZvcm1hdHRlcnMuZ2V0TGlzdEZvcm1hdChsb2NhbGUsIG9wdGlvbnMpLmZvcm1hdFRvUGFydHMoc2VyaWFsaXplZFZhbHVlKS5tYXAocGFydCA9PiBwYXJ0LnR5cGUgPT09ICdsaXRlcmFsJyA/IHBhcnQudmFsdWUgOiByaWNoVmFsdWVzLmdldChwYXJ0LnZhbHVlKSB8fCBwYXJ0LnZhbHVlKTtcbiAgICAgIGlmIChyaWNoVmFsdWVzLnNpemUgPiAwKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oJycpO1xuICAgICAgfVxuICAgIH0sICgpID0+IFN0cmluZyh2YWx1ZSkpO1xuICB9XG4gIHJldHVybiB7XG4gICAgZGF0ZVRpbWUsXG4gICAgbnVtYmVyLFxuICAgIHJlbGF0aXZlVGltZSxcbiAgICBsaXN0LFxuICAgIGRhdGVUaW1lUmFuZ2VcbiAgfTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVNZXNzYWdlc1NlZ21lbnQobWVzc2FnZXMsIGludmFsaWRLZXlMYWJlbHMsIHBhcmVudFBhdGgpIHtcbiAgT2JqZWN0LmVudHJpZXMobWVzc2FnZXMpLmZvckVhY2goKFtrZXksIG1lc3NhZ2VPck1lc3NhZ2VzXSkgPT4ge1xuICAgIGlmIChrZXkuaW5jbHVkZXMoJy4nKSkge1xuICAgICAgbGV0IGtleUxhYmVsID0ga2V5O1xuICAgICAgaWYgKHBhcmVudFBhdGgpIGtleUxhYmVsICs9IGAgKGF0ICR7cGFyZW50UGF0aH0pYDtcbiAgICAgIGludmFsaWRLZXlMYWJlbHMucHVzaChrZXlMYWJlbCk7XG4gICAgfVxuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cbiAgICBpZiAobWVzc2FnZU9yTWVzc2FnZXMgIT0gbnVsbCAmJiB0eXBlb2YgbWVzc2FnZU9yTWVzc2FnZXMgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YWxpZGF0ZU1lc3NhZ2VzU2VnbWVudChtZXNzYWdlT3JNZXNzYWdlcywgaW52YWxpZEtleUxhYmVscywgam9pblBhdGgocGFyZW50UGF0aCwga2V5KSk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlTWVzc2FnZXMobWVzc2FnZXMsIG9uRXJyb3IpIHtcbiAgY29uc3QgaW52YWxpZEtleUxhYmVscyA9IFtdO1xuICB2YWxpZGF0ZU1lc3NhZ2VzU2VnbWVudChtZXNzYWdlcywgaW52YWxpZEtleUxhYmVscyk7XG4gIGlmIChpbnZhbGlkS2V5TGFiZWxzLmxlbmd0aCA+IDApIHtcbiAgICBvbkVycm9yKG5ldyBJbnRsRXJyb3IoSW50bEVycm9yQ29kZS5JTlZBTElEX0tFWSwgYE5hbWVzcGFjZSBrZXlzIGNhbiBub3QgY29udGFpbiB0aGUgY2hhcmFjdGVyIFwiLlwiIGFzIHRoaXMgaXMgdXNlZCB0byBleHByZXNzIG5lc3RpbmcuIFBsZWFzZSByZW1vdmUgaXQgb3IgcmVwbGFjZSBpdCB3aXRoIGFub3RoZXIgY2hhcmFjdGVyLlxuXG5JbnZhbGlkICR7aW52YWxpZEtleUxhYmVscy5sZW5ndGggPT09IDEgPyAna2V5JyA6ICdrZXlzJ306ICR7aW52YWxpZEtleUxhYmVscy5qb2luKCcsICcpfVxuXG5JZiB5b3UncmUgbWlncmF0aW5nIGZyb20gYSBmbGF0IHN0cnVjdHVyZSwgeW91IGNhbiBjb252ZXJ0IHlvdXIgbWVzc2FnZXMgYXMgZm9sbG93czpcblxuaW1wb3J0IHtzZXR9IGZyb20gXCJsb2Rhc2hcIjtcblxuY29uc3QgaW5wdXQgPSB7XG4gIFwib25lLm9uZVwiOiBcIjEuMVwiLFxuICBcIm9uZS50d29cIjogXCIxLjJcIixcbiAgXCJ0d28ub25lLm9uZVwiOiBcIjIuMS4xXCJcbn07XG5cbmNvbnN0IG91dHB1dCA9IE9iamVjdC5lbnRyaWVzKGlucHV0KS5yZWR1Y2UoXG4gIChhY2MsIFtrZXksIHZhbHVlXSkgPT4gc2V0KGFjYywga2V5LCB2YWx1ZSksXG4gIHt9XG4pO1xuXG4vLyBPdXRwdXQ6XG4vL1xuLy8ge1xuLy8gICBcIm9uZVwiOiB7XG4vLyAgICAgXCJvbmVcIjogXCIxLjFcIixcbi8vICAgICBcInR3b1wiOiBcIjEuMlwiXG4vLyAgIH0sXG4vLyAgIFwidHdvXCI6IHtcbi8vICAgICBcIm9uZVwiOiB7XG4vLyAgICAgICBcIm9uZVwiOiBcIjIuMS4xXCJcbi8vICAgICB9XG4vLyAgIH1cbi8vIH1cbmAgKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBFbmhhbmNlcyB0aGUgaW5jb21pbmcgcHJvcHMgd2l0aCBkZWZhdWx0cy5cbiAqL1xuZnVuY3Rpb24gaW5pdGlhbGl6ZUNvbmZpZyh7XG4gIGZvcm1hdHMsXG4gIGdldE1lc3NhZ2VGYWxsYmFjayxcbiAgbWVzc2FnZXMsXG4gIG9uRXJyb3IsXG4gIC4uLnJlc3Rcbn0pIHtcbiAgY29uc3QgZmluYWxPbkVycm9yID0gb25FcnJvciB8fCBkZWZhdWx0T25FcnJvcjtcbiAgY29uc3QgZmluYWxHZXRNZXNzYWdlRmFsbGJhY2sgPSBnZXRNZXNzYWdlRmFsbGJhY2sgfHwgZGVmYXVsdEdldE1lc3NhZ2VGYWxsYmFjaztcbiAge1xuICAgIGlmIChtZXNzYWdlcykge1xuICAgICAgdmFsaWRhdGVNZXNzYWdlcyhtZXNzYWdlcywgZmluYWxPbkVycm9yKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5yZXN0LFxuICAgIGZvcm1hdHM6IGZvcm1hdHMgfHwgdW5kZWZpbmVkLFxuICAgIG1lc3NhZ2VzOiBtZXNzYWdlcyB8fCB1bmRlZmluZWQsXG4gICAgb25FcnJvcjogZmluYWxPbkVycm9yLFxuICAgIGdldE1lc3NhZ2VGYWxsYmFjazogZmluYWxHZXRNZXNzYWdlRmFsbGJhY2tcbiAgfTtcbn1cblxuZXhwb3J0IHsgSW50bEVycm9yIGFzIEksIEludGxFcnJvckNvZGUgYXMgYSwgY3JlYXRlSW50bEZvcm1hdHRlcnMgYXMgYiwgY3JlYXRlRm9ybWF0dGVyIGFzIGMsIGNyZWF0ZUNhY2hlIGFzIGQsIGNyZWF0ZUJhc2VUcmFuc2xhdG9yIGFzIGUsIGRlZmF1bHRHZXRNZXNzYWdlRmFsbGJhY2sgYXMgZiwgZGVmYXVsdE9uRXJyb3IgYXMgZywgaW5pdGlhbGl6ZUNvbmZpZyBhcyBpLCByZXNvbHZlTmFtZXNwYWNlIGFzIHIgfTtcbiJdLCJuYW1lcyI6WyJJbnRsTWVzc2FnZUZvcm1hdCIsImlzVmFsaWRFbGVtZW50IiwiY2xvbmVFbGVtZW50IiwibWVtb2l6ZSIsInN0cmF0ZWdpZXMiLCJJbnRsRXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwiY29kZSIsIm9yaWdpbmFsTWVzc2FnZSIsIm1lc3NhZ2UiLCJJbnRsRXJyb3JDb2RlIiwiY29udmVydEZvcm1hdHNUb0ludGxNZXNzYWdlRm9ybWF0IiwiZ2xvYmFsRm9ybWF0cyIsImlubGluZUZvcm1hdHMiLCJ0aW1lWm9uZSIsIm1mRGF0ZURlZmF1bHRzIiwiZm9ybWF0cyIsImRhdGUiLCJtZlRpbWVEZWZhdWx0cyIsInRpbWUiLCJkYXRlVGltZUZvcm1hdHMiLCJfb2JqZWN0U3ByZWFkIiwiZGF0ZVRpbWUiLCJhbGxGb3JtYXRzIiwibnVtYmVyIiwiZm9yRWFjaCIsInByb3BlcnR5Iiwia2V5IiwidmFsdWUiLCJPYmplY3QiLCJlbnRyaWVzIiwiam9pblBhdGgiLCJwYXJ0cyIsImZpbHRlciIsIkJvb2xlYW4iLCJqb2luIiwiZGVmYXVsdEdldE1lc3NhZ2VGYWxsYmFjayIsInByb3BzIiwibmFtZXNwYWNlIiwiZGVmYXVsdE9uRXJyb3IiLCJlcnJvciIsImNvbnNvbGUiLCJjcmVhdGVDYWNoZSIsInJlbGF0aXZlVGltZSIsInBsdXJhbFJ1bGVzIiwibGlzdCIsImRpc3BsYXlOYW1lcyIsImNyZWF0ZU1lbW9DYWNoZSIsInN0b3JlIiwiY3JlYXRlIiwiZ2V0Iiwic2V0IiwibWVtb0ZuIiwiZm4iLCJjYWNoZSIsInN0cmF0ZWd5IiwidmFyaWFkaWMiLCJtZW1vQ29uc3RydWN0b3IiLCJDb25zdHJ1Y3RvckZuIiwiYXJncyIsImNyZWF0ZUludGxGb3JtYXR0ZXJzIiwiZ2V0RGF0ZVRpbWVGb3JtYXQiLCJJbnRsIiwiRGF0ZVRpbWVGb3JtYXQiLCJnZXROdW1iZXJGb3JtYXQiLCJOdW1iZXJGb3JtYXQiLCJnZXRQbHVyYWxSdWxlcyIsIlBsdXJhbFJ1bGVzIiwiZ2V0UmVsYXRpdmVUaW1lRm9ybWF0IiwiUmVsYXRpdmVUaW1lRm9ybWF0IiwiZ2V0TGlzdEZvcm1hdCIsIkxpc3RGb3JtYXQiLCJnZXREaXNwbGF5TmFtZXMiLCJEaXNwbGF5TmFtZXMiLCJjcmVhdGVNZXNzYWdlRm9ybWF0dGVyIiwiaW50bEZvcm1hdHRlcnMiLCJnZXRNZXNzYWdlRm9ybWF0IiwiZm9ybWF0dGVycyIsInJlc29sdmVQYXRoIiwibG9jYWxlIiwibWVzc2FnZXMiLCJmdWxsS2V5Iiwic3BsaXQiLCJwYXJ0IiwibmV4dCIsInByZXBhcmVUcmFuc2xhdGlvblZhbHVlcyIsInZhbHVlcyIsInRyYW5zZm9ybWVkVmFsdWVzIiwia2V5cyIsImluZGV4IiwidHJhbnNmb3JtZWQiLCJjaHVua3MiLCJyZXN1bHQiLCJnZXRNZXNzYWdlc09yRXJyb3IiLCJvbkVycm9yIiwicmV0cmlldmVkTWVzc2FnZXMiLCJpbnRsRXJyb3IiLCJNSVNTSU5HX01FU1NBR0UiLCJnZXRQbGFpbk1lc3NhZ2UiLCJjYW5kaWRhdGUiLCJ0ZXN0IiwidW5kZWZpbmVkIiwiY3JlYXRlQmFzZVRyYW5zbGF0b3IiLCJjb25maWciLCJtZXNzYWdlc09yRXJyb3IiLCJjcmVhdGVCYXNlVHJhbnNsYXRvckltcGwiLCJnZXRNZXNzYWdlRmFsbGJhY2siLCJoYXNNZXNzYWdlc0Vycm9yIiwiZ2V0RmFsbGJhY2tGcm9tRXJyb3JBbmROb3RpZnkiLCJ0cmFuc2xhdGVCYXNlRm4iLCJlcnJvck1lc3NhZ2UiLCJBcnJheSIsImlzQXJyYXkiLCJJTlZBTElEX01FU1NBR0UiLCJJTlNVRkZJQ0lFTlRfUEFUSCIsIm1lc3NhZ2VGb3JtYXQiLCJwbGFpbk1lc3NhZ2UiLCJsb2NhbGVzIiwib3B0aW9ucyIsInRocm93bkVycm9yIiwiZm9ybWF0dGVkTWVzc2FnZSIsImZvcm1hdCIsIlN0cmluZyIsIkZPUk1BVFRJTkdfRVJST1IiLCJ0cmFuc2xhdGVGbiIsInJpY2giLCJtYXJrdXAiLCJyYXciLCJoYXMiLCJyZXNvbHZlTmFtZXNwYWNlIiwibmFtZXNwYWNlUHJlZml4Iiwic2xpY2UiLCJsZW5ndGgiLCJTRUNPTkQiLCJNSU5VVEUiLCJIT1VSIiwiREFZIiwiV0VFSyIsIk1PTlRIIiwiUVVBUlRFUiIsIllFQVIiLCJVTklUX1NFQ09ORFMiLCJzZWNvbmQiLCJzZWNvbmRzIiwibWludXRlIiwibWludXRlcyIsImhvdXIiLCJob3VycyIsImRheSIsImRheXMiLCJ3ZWVrIiwid2Vla3MiLCJtb250aCIsIm1vbnRocyIsInF1YXJ0ZXIiLCJxdWFydGVycyIsInllYXIiLCJ5ZWFycyIsInJlc29sdmVSZWxhdGl2ZVRpbWVVbml0IiwiYWJzVmFsdWUiLCJNYXRoIiwiYWJzIiwiY2FsY3VsYXRlUmVsYXRpdmVUaW1lVmFsdWUiLCJ1bml0Iiwicm91bmQiLCJjcmVhdGVGb3JtYXR0ZXIiLCJfY2FjaGUiLCJfZm9ybWF0dGVycyIsImdsb2JhbFRpbWVab25lIiwiYXBwbHlUaW1lWm9uZSIsIkVOVklST05NRU5UX0ZBTExCQUNLIiwicmVzb2x2ZUZvcm1hdE9yT3B0aW9ucyIsInR5cGVGb3JtYXRzIiwiZm9ybWF0T3JPcHRpb25zIiwib3ZlcnJpZGVzIiwiZm9ybWF0TmFtZSIsIk1JU1NJTkdfRk9STUFUIiwiZ2V0Rm9ybWF0dGVkVmFsdWUiLCJmb3JtYXR0ZXIiLCJnZXRGYWxsYmFjayIsImRhdGVUaW1lUmFuZ2UiLCJzdGFydCIsImVuZCIsImZvcm1hdFJhbmdlIiwiZ2V0R2xvYmFsTm93Iiwibm93IiwiRGF0ZSIsIm5vd09yT3B0aW9ucyIsIm5vd0RhdGUiLCJvcHRzIiwic3R5bGUiLCJudW1iZXJpbmdTeXN0ZW0iLCJkYXRlRGF0ZSIsImdldFRpbWUiLCJudW1lcmljIiwic2VyaWFsaXplZFZhbHVlIiwicmljaFZhbHVlcyIsIk1hcCIsIml0ZW0iLCJzZXJpYWxpemVkSXRlbSIsInB1c2giLCJmb3JtYXRUb1BhcnRzIiwibWFwIiwidHlwZSIsInNpemUiLCJ2YWxpZGF0ZU1lc3NhZ2VzU2VnbWVudCIsImludmFsaWRLZXlMYWJlbHMiLCJwYXJlbnRQYXRoIiwibWVzc2FnZU9yTWVzc2FnZXMiLCJpbmNsdWRlcyIsImtleUxhYmVsIiwidmFsaWRhdGVNZXNzYWdlcyIsIklOVkFMSURfS0VZIiwiaW5pdGlhbGl6ZUNvbmZpZyIsIl9yZWYiLCJyZXN0IiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIiwiX2V4Y2x1ZGVkIiwiZmluYWxPbkVycm9yIiwiZmluYWxHZXRNZXNzYWdlRmFsbGJhY2siLCJJIiwiYSIsImIiLCJjIiwiZCIsImUiLCJmIiwiZyIsImkiLCJyIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/use-intl/dist/esm/development/initializeConfig-DPFnvsUO.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/use-intl/dist/esm/development/initializeConfig-DPFnvsUO.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/use-intl/dist/esm/development/initializeConfig-DPFnvsUO.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   I: () => (/* binding */ IntlError),\n/* harmony export */   a: () => (/* binding */ IntlErrorCode),\n/* harmony export */   b: () => (/* binding */ createIntlFormatters),\n/* harmony export */   c: () => (/* binding */ createFormatter),\n/* harmony export */   d: () => (/* binding */ createCache),\n/* harmony export */   e: () => (/* binding */ createBaseTranslator),\n/* harmony export */   f: () => (/* binding */ defaultGetMessageFallback),\n/* harmony export */   g: () => (/* binding */ defaultOnError),\n/* harmony export */   i: () => (/* binding */ initializeConfig),\n/* harmony export */   r: () => (/* binding */ resolveNamespace)\n/* harmony export */ });\n/* harmony import */ var intl_messageformat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! intl-messageformat */ \"(ssr)/../../node_modules/intl-messageformat/lib/src/core.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/../../node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _formatjs_fast_memoize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @formatjs/fast-memoize */ \"(ssr)/../../node_modules/@formatjs/fast-memoize/lib/index.js\");\nconst _excluded = [\"formats\", \"getMessageFallback\", \"messages\", \"onError\"];\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\n\n\nclass IntlError extends Error {\n  constructor(code, originalMessage) {\n    let message = code;\n    if (originalMessage) {\n      message += ': ' + originalMessage;\n    }\n    super(message);\n    this.code = code;\n    if (originalMessage) {\n      this.originalMessage = originalMessage;\n    }\n  }\n}\nvar IntlErrorCode = /*#__PURE__*/function (IntlErrorCode) {\n  IntlErrorCode[\"MISSING_MESSAGE\"] = \"MISSING_MESSAGE\";\n  IntlErrorCode[\"MISSING_FORMAT\"] = \"MISSING_FORMAT\";\n  IntlErrorCode[\"ENVIRONMENT_FALLBACK\"] = \"ENVIRONMENT_FALLBACK\";\n  IntlErrorCode[\"INSUFFICIENT_PATH\"] = \"INSUFFICIENT_PATH\";\n  IntlErrorCode[\"INVALID_MESSAGE\"] = \"INVALID_MESSAGE\";\n  IntlErrorCode[\"INVALID_KEY\"] = \"INVALID_KEY\";\n  IntlErrorCode[\"FORMATTING_ERROR\"] = \"FORMATTING_ERROR\";\n  return IntlErrorCode;\n}(IntlErrorCode || {});\n\n/**\n * `intl-messageformat` uses separate keys for `date` and `time`, but there's\n * only one native API: `Intl.DateTimeFormat`. Additionally you might want to\n * include both a time and a date in a value, therefore the separation doesn't\n * seem so useful. We offer a single `dateTime` namespace instead, but we have\n * to convert the format before `intl-messageformat` can be used.\n */\nfunction convertFormatsToIntlMessageFormat(globalFormats, inlineFormats, timeZone) {\n  const mfDateDefaults = intl_messageformat__WEBPACK_IMPORTED_MODULE_2__.IntlMessageFormat.formats.date;\n  const mfTimeDefaults = intl_messageformat__WEBPACK_IMPORTED_MODULE_2__.IntlMessageFormat.formats.time;\n  const dateTimeFormats = _objectSpread(_objectSpread({}, globalFormats?.dateTime), inlineFormats?.dateTime);\n  const allFormats = {\n    date: _objectSpread(_objectSpread({}, mfDateDefaults), dateTimeFormats),\n    time: _objectSpread(_objectSpread({}, mfTimeDefaults), dateTimeFormats),\n    number: _objectSpread(_objectSpread({}, globalFormats?.number), inlineFormats?.number)\n    // (list is not supported in ICU messages)\n  };\n\n  if (timeZone) {\n    // The only way to set a time zone with `intl-messageformat` is to merge it into the formats\n    // https://github.com/formatjs/formatjs/blob/8256c5271505cf2606e48e3c97ecdd16ede4f1b5/packages/intl/src/message.ts#L15\n    ['date', 'time'].forEach(property => {\n      const formats = allFormats[property];\n      for (const [key, value] of Object.entries(formats)) {\n        formats[key] = _objectSpread({\n          timeZone\n        }, value);\n      }\n    });\n  }\n  return allFormats;\n}\nfunction joinPath(...parts) {\n  return parts.filter(Boolean).join('.');\n}\n\n/**\n * Contains defaults that are used for all entry points into the core.\n * See also `InitializedIntlConfiguration`.\n */\n\nfunction defaultGetMessageFallback(props) {\n  return joinPath(props.namespace, props.key);\n}\nfunction defaultOnError(error) {\n  console.error(error);\n}\nfunction createCache() {\n  return {\n    dateTime: {},\n    number: {},\n    message: {},\n    relativeTime: {},\n    pluralRules: {},\n    list: {},\n    displayNames: {}\n  };\n}\nfunction createMemoCache(store) {\n  return {\n    create() {\n      return {\n        get(key) {\n          return store[key];\n        },\n        set(key, value) {\n          store[key] = value;\n        }\n      };\n    }\n  };\n}\nfunction memoFn(fn, cache) {\n  return (0,_formatjs_fast_memoize__WEBPACK_IMPORTED_MODULE_1__.memoize)(fn, {\n    cache: createMemoCache(cache),\n    strategy: _formatjs_fast_memoize__WEBPACK_IMPORTED_MODULE_1__.strategies.variadic\n  });\n}\nfunction memoConstructor(ConstructorFn, cache) {\n  return memoFn((...args) => new ConstructorFn(...args), cache);\n}\nfunction createIntlFormatters(cache) {\n  const getDateTimeFormat = memoConstructor(Intl.DateTimeFormat, cache.dateTime);\n  const getNumberFormat = memoConstructor(Intl.NumberFormat, cache.number);\n  const getPluralRules = memoConstructor(Intl.PluralRules, cache.pluralRules);\n  const getRelativeTimeFormat = memoConstructor(Intl.RelativeTimeFormat, cache.relativeTime);\n  const getListFormat = memoConstructor(Intl.ListFormat, cache.list);\n  const getDisplayNames = memoConstructor(Intl.DisplayNames, cache.displayNames);\n  return {\n    getDateTimeFormat,\n    getNumberFormat,\n    getPluralRules,\n    getRelativeTimeFormat,\n    getListFormat,\n    getDisplayNames\n  };\n}\n\n// Placed here for improved tree shaking. Somehow when this is placed in\n// `formatters.tsx`, then it can't be shaken off from `next-intl`.\nfunction createMessageFormatter(cache, intlFormatters) {\n  const getMessageFormat = memoFn((...args) => new intl_messageformat__WEBPACK_IMPORTED_MODULE_2__.IntlMessageFormat(args[0], args[1], args[2], _objectSpread({\n    formatters: intlFormatters\n  }, args[3])), cache.message);\n  return getMessageFormat;\n}\nfunction resolvePath(locale, messages, key, namespace) {\n  const fullKey = joinPath(namespace, key);\n  if (!messages) {\n    throw new Error(`No messages available at \\`${namespace}\\`.`);\n  }\n  let message = messages;\n  key.split('.').forEach(part => {\n    const next = message[part];\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (part == null || next == null) {\n      throw new Error(`Could not resolve \\`${fullKey}\\` in messages for locale \\`${locale}\\`.`);\n    }\n    message = next;\n  });\n  return message;\n}\nfunction prepareTranslationValues(values) {\n  // Workaround for https://github.com/formatjs/formatjs/issues/1467\n  const transformedValues = {};\n  Object.keys(values).forEach(key => {\n    let index = 0;\n    const value = values[key];\n    let transformed;\n    if (typeof value === 'function') {\n      transformed = chunks => {\n        const result = value(chunks);\n        return /*#__PURE__*/ /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(result) ? /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(result, {\n          key: key + index++\n        }) : result;\n      };\n    } else {\n      transformed = value;\n    }\n    transformedValues[key] = transformed;\n  });\n  return transformedValues;\n}\nfunction getMessagesOrError(locale, messages, namespace, onError = defaultOnError) {\n  try {\n    if (!messages) {\n      throw new Error(`No messages were configured.`);\n    }\n    const retrievedMessages = namespace ? resolvePath(locale, messages, namespace) : messages;\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (!retrievedMessages) {\n      throw new Error(`No messages for namespace \\`${namespace}\\` found.`);\n    }\n    return retrievedMessages;\n  } catch (error) {\n    const intlError = new IntlError(IntlErrorCode.MISSING_MESSAGE, error.message);\n    onError(intlError);\n    return intlError;\n  }\n}\nfunction getPlainMessage(candidate, values) {\n  // To improve runtime performance, only compile message if:\n  return (\n    // 1. Values are provided\n    values ||\n    // 2. There are escaped braces (e.g. \"'{name'}\")\n    /'[{}]/.test(candidate) ||\n    // 3. There are missing arguments or tags (dev-only error handling)\n    /<|{/.test(candidate) ? undefined // Compile\n    : candidate // Don't compile\n  );\n}\n\nfunction createBaseTranslator(config) {\n  const messagesOrError = getMessagesOrError(config.locale, config.messages, config.namespace, config.onError);\n  return createBaseTranslatorImpl(_objectSpread(_objectSpread({}, config), {}, {\n    messagesOrError\n  }));\n}\nfunction createBaseTranslatorImpl({\n  cache,\n  formats: globalFormats,\n  formatters,\n  getMessageFallback = defaultGetMessageFallback,\n  locale,\n  messagesOrError,\n  namespace,\n  onError,\n  timeZone\n}) {\n  const hasMessagesError = messagesOrError instanceof IntlError;\n  function getFallbackFromErrorAndNotify(key, code, message) {\n    const error = new IntlError(code, message);\n    onError(error);\n    return getMessageFallback({\n      error,\n      key,\n      namespace\n    });\n  }\n  function translateBaseFn( /** Use a dot to indicate a level of nesting (e.g. `namespace.nestedLabel`). */\n  key, /** Key value pairs for values to interpolate into the message. */\n  values, /** Provide custom formats for numbers, dates and times. */\n  formats) {\n    if (hasMessagesError) {\n      // We have already warned about this during render\n      return getMessageFallback({\n        error: messagesOrError,\n        key,\n        namespace\n      });\n    }\n    const messages = messagesOrError;\n    let message;\n    try {\n      message = resolvePath(locale, messages, key, namespace);\n    } catch (error) {\n      return getFallbackFromErrorAndNotify(key, IntlErrorCode.MISSING_MESSAGE, error.message);\n    }\n    if (typeof message === 'object') {\n      let code, errorMessage;\n      if (Array.isArray(message)) {\n        code = IntlErrorCode.INVALID_MESSAGE;\n        {\n          errorMessage = `Message at \\`${joinPath(namespace, key)}\\` resolved to an array, but only strings are supported. See https://next-intl.dev/docs/usage/messages#arrays-of-messages`;\n        }\n      } else {\n        code = IntlErrorCode.INSUFFICIENT_PATH;\n        {\n          errorMessage = `Message at \\`${joinPath(namespace, key)}\\` resolved to an object, but only strings are supported. Use a \\`.\\` to retrieve nested messages. See https://next-intl.dev/docs/usage/messages#structuring-messages`;\n        }\n      }\n      return getFallbackFromErrorAndNotify(key, code, errorMessage);\n    }\n    let messageFormat;\n\n    // Hot path that avoids creating an `IntlMessageFormat` instance\n    const plainMessage = getPlainMessage(message, values);\n    if (plainMessage) return plainMessage;\n\n    // Lazy init the message formatter for better tree\n    // shaking in case message formatting is not used.\n    if (!formatters.getMessageFormat) {\n      formatters.getMessageFormat = createMessageFormatter(cache, formatters);\n    }\n    try {\n      messageFormat = formatters.getMessageFormat(message, locale, convertFormatsToIntlMessageFormat(globalFormats, formats, timeZone), {\n        formatters: _objectSpread(_objectSpread({}, formatters), {}, {\n          getDateTimeFormat(locales, options) {\n            // Workaround for https://github.com/formatjs/formatjs/issues/4279\n            return formatters.getDateTimeFormat(locales, _objectSpread({\n              timeZone\n            }, options));\n          }\n        })\n      });\n    } catch (error) {\n      const thrownError = error;\n      return getFallbackFromErrorAndNotify(key, IntlErrorCode.INVALID_MESSAGE, thrownError.message + ('originalMessage' in thrownError ? ` (${thrownError.originalMessage})` : ''));\n    }\n    try {\n      const formattedMessage = messageFormat.format(\n      // @ts-expect-error `intl-messageformat` expects a different format\n      // for rich text elements since a recent minor update. This\n      // needs to be evaluated in detail, possibly also in regards\n      // to be able to format to parts.\n      values ? prepareTranslationValues(values) : values);\n      if (formattedMessage == null) {\n        throw new Error(`Unable to format \\`${key}\\` in ${namespace ? `namespace \\`${namespace}\\`` : 'messages'}`);\n      }\n\n      // Limit the function signature to return strings or React elements\n      return /*#__PURE__*/ /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(formattedMessage) ||\n      // Arrays of React elements\n      Array.isArray(formattedMessage) || typeof formattedMessage === 'string' ? formattedMessage : String(formattedMessage);\n    } catch (error) {\n      return getFallbackFromErrorAndNotify(key, IntlErrorCode.FORMATTING_ERROR, error.message);\n    }\n  }\n  function translateFn( /** Use a dot to indicate a level of nesting (e.g. `namespace.nestedLabel`). */\n  key, /** Key value pairs for values to interpolate into the message. */\n  values, /** Provide custom formats for numbers, dates and times. */\n  formats) {\n    const result = translateBaseFn(key, values, formats);\n    if (typeof result !== 'string') {\n      return getFallbackFromErrorAndNotify(key, IntlErrorCode.INVALID_MESSAGE, `The message \\`${key}\\` in ${namespace ? `namespace \\`${namespace}\\`` : 'messages'} didn't resolve to a string. If you want to format rich text, use \\`t.rich\\` instead.`);\n    }\n    return result;\n  }\n  translateFn.rich = translateBaseFn;\n\n  // Augment `translateBaseFn` to return plain strings\n  translateFn.markup = (key, values, formats) => {\n    const result = translateBaseFn(key,\n    // @ts-expect-error -- `MarkupTranslationValues` is practically a sub type\n    // of `RichTranslationValues` but TypeScript isn't smart enough here.\n    values, formats);\n    if (typeof result !== 'string') {\n      const error = new IntlError(IntlErrorCode.FORMATTING_ERROR, \"`t.markup` only accepts functions for formatting that receive and return strings.\\n\\nE.g. t.markup('markup', {b: (chunks) => `<b>${chunks}</b>`})\");\n      onError(error);\n      return getMessageFallback({\n        error,\n        key,\n        namespace\n      });\n    }\n    return result;\n  };\n  translateFn.raw = key => {\n    if (hasMessagesError) {\n      // We have already warned about this during render\n      return getMessageFallback({\n        error: messagesOrError,\n        key,\n        namespace\n      });\n    }\n    const messages = messagesOrError;\n    try {\n      return resolvePath(locale, messages, key, namespace);\n    } catch (error) {\n      return getFallbackFromErrorAndNotify(key, IntlErrorCode.MISSING_MESSAGE, error.message);\n    }\n  };\n  translateFn.has = key => {\n    if (hasMessagesError) {\n      return false;\n    }\n    try {\n      resolvePath(locale, messagesOrError, key, namespace);\n      return true;\n    } catch {\n      return false;\n    }\n  };\n  return translateFn;\n}\n\n/**\n * For the strictly typed messages to work we have to wrap the namespace into\n * a mandatory prefix. See https://stackoverflow.com/a/71529575/343045\n */\nfunction resolveNamespace(namespace, namespacePrefix) {\n  return namespace === namespacePrefix ? undefined : namespace.slice((namespacePrefix + '.').length);\n}\nconst SECOND = 1;\nconst MINUTE = SECOND * 60;\nconst HOUR = MINUTE * 60;\nconst DAY = HOUR * 24;\nconst WEEK = DAY * 7;\nconst MONTH = DAY * (365 / 12); // Approximation\nconst QUARTER = MONTH * 3;\nconst YEAR = DAY * 365;\nconst UNIT_SECONDS = {\n  second: SECOND,\n  seconds: SECOND,\n  minute: MINUTE,\n  minutes: MINUTE,\n  hour: HOUR,\n  hours: HOUR,\n  day: DAY,\n  days: DAY,\n  week: WEEK,\n  weeks: WEEK,\n  month: MONTH,\n  months: MONTH,\n  quarter: QUARTER,\n  quarters: QUARTER,\n  year: YEAR,\n  years: YEAR\n};\nfunction resolveRelativeTimeUnit(seconds) {\n  const absValue = Math.abs(seconds);\n  if (absValue < MINUTE) {\n    return 'second';\n  } else if (absValue < HOUR) {\n    return 'minute';\n  } else if (absValue < DAY) {\n    return 'hour';\n  } else if (absValue < WEEK) {\n    return 'day';\n  } else if (absValue < MONTH) {\n    return 'week';\n  } else if (absValue < YEAR) {\n    return 'month';\n  }\n  return 'year';\n}\nfunction calculateRelativeTimeValue(seconds, unit) {\n  // We have to round the resulting values, as `Intl.RelativeTimeFormat`\n  // will include fractions like '2.1 hours ago'.\n  return Math.round(seconds / UNIT_SECONDS[unit]);\n}\nfunction createFormatter(props) {\n  const {\n    _cache: cache = createCache(),\n    _formatters: formatters = createIntlFormatters(cache),\n    formats,\n    locale,\n    onError = defaultOnError,\n    timeZone: globalTimeZone\n  } = props;\n  function applyTimeZone(options) {\n    if (!options?.timeZone) {\n      if (globalTimeZone) {\n        options = _objectSpread(_objectSpread({}, options), {}, {\n          timeZone: globalTimeZone\n        });\n      } else {\n        onError(new IntlError(IntlErrorCode.ENVIRONMENT_FALLBACK, `The \\`timeZone\\` parameter wasn't provided and there is no global default configured. Consider adding a global default to avoid markup mismatches caused by environment differences. Learn more: https://next-intl.dev/docs/configuration#time-zone`));\n      }\n    }\n    return options;\n  }\n  function resolveFormatOrOptions(typeFormats, formatOrOptions, overrides) {\n    let options;\n    if (typeof formatOrOptions === 'string') {\n      const formatName = formatOrOptions;\n      options = typeFormats?.[formatName];\n      if (!options) {\n        const error = new IntlError(IntlErrorCode.MISSING_FORMAT, `Format \\`${formatName}\\` is not available.`);\n        onError(error);\n        throw error;\n      }\n    } else {\n      options = formatOrOptions;\n    }\n    if (overrides) {\n      options = _objectSpread(_objectSpread({}, options), overrides);\n    }\n    return options;\n  }\n  function getFormattedValue(formatOrOptions, overrides, typeFormats, formatter, getFallback) {\n    let options;\n    try {\n      options = resolveFormatOrOptions(typeFormats, formatOrOptions, overrides);\n    } catch {\n      return getFallback();\n    }\n    try {\n      return formatter(options);\n    } catch (error) {\n      onError(new IntlError(IntlErrorCode.FORMATTING_ERROR, error.message));\n      return getFallback();\n    }\n  }\n  function dateTime(value, formatOrOptions, overrides) {\n    return getFormattedValue(formatOrOptions, overrides, formats?.dateTime, options => {\n      options = applyTimeZone(options);\n      return formatters.getDateTimeFormat(locale, options).format(value);\n    }, () => String(value));\n  }\n  function dateTimeRange(start, end, formatOrOptions, overrides) {\n    return getFormattedValue(formatOrOptions, overrides, formats?.dateTime, options => {\n      options = applyTimeZone(options);\n      return formatters.getDateTimeFormat(locale, options).formatRange(start, end);\n    }, () => [dateTime(start), dateTime(end)].join(' – '));\n  }\n  function number(value, formatOrOptions, overrides) {\n    return getFormattedValue(formatOrOptions, overrides, formats?.number, options => formatters.getNumberFormat(locale, options).format(value), () => String(value));\n  }\n  function getGlobalNow() {\n    // Only read when necessary to avoid triggering a `dynamicIO` error\n    // unnecessarily (`now` is only needed for `format.relativeTime`)\n    if (props.now) {\n      return props.now;\n    } else {\n      onError(new IntlError(IntlErrorCode.ENVIRONMENT_FALLBACK, `The \\`now\\` parameter wasn't provided to \\`relativeTime\\` and there is no global default configured, therefore the current time will be used as a fallback. See https://next-intl.dev/docs/usage/dates-times#relative-times-usenow`));\n      return new Date();\n    }\n  }\n  function relativeTime(date, nowOrOptions) {\n    try {\n      let nowDate, unit;\n      const opts = {};\n      if (nowOrOptions instanceof Date || typeof nowOrOptions === 'number') {\n        nowDate = new Date(nowOrOptions);\n      } else if (nowOrOptions) {\n        if (nowOrOptions.now != null) {\n          nowDate = new Date(nowOrOptions.now);\n        } else {\n          nowDate = getGlobalNow();\n        }\n        unit = nowOrOptions.unit;\n        opts.style = nowOrOptions.style;\n        // @ts-expect-error -- Types are slightly outdated\n        opts.numberingSystem = nowOrOptions.numberingSystem;\n      }\n      if (!nowDate) {\n        nowDate = getGlobalNow();\n      }\n      const dateDate = new Date(date);\n      const seconds = (dateDate.getTime() - nowDate.getTime()) / 1000;\n      if (!unit) {\n        unit = resolveRelativeTimeUnit(seconds);\n      }\n\n      // `numeric: 'auto'` can theoretically produce output like \"yesterday\",\n      // but it only works with integers. E.g. -1 day will produce \"yesterday\",\n      // but -1.1 days will produce \"-1.1 days\". Rounding before formatting is\n      // not desired, as the given dates might cross a threshold were the\n      // output isn't correct anymore. Example: 2024-01-08T23:00:00.000Z and\n      // 2024-01-08T01:00:00.000Z would produce \"yesterday\", which is not the\n      // case. By using `always` we can ensure correct output. The only exception\n      // is the formatting of times <1 second as \"now\".\n      opts.numeric = unit === 'second' ? 'auto' : 'always';\n      const value = calculateRelativeTimeValue(seconds, unit);\n      return formatters.getRelativeTimeFormat(locale, opts).format(value, unit);\n    } catch (error) {\n      onError(new IntlError(IntlErrorCode.FORMATTING_ERROR, error.message));\n      return String(date);\n    }\n  }\n  function list(value, formatOrOptions, overrides) {\n    const serializedValue = [];\n    const richValues = new Map();\n\n    // `formatToParts` only accepts strings, therefore we have to temporarily\n    // replace React elements with a placeholder ID that can be used to retrieve\n    // the original value afterwards.\n    let index = 0;\n    for (const item of value) {\n      let serializedItem;\n      if (typeof item === 'object') {\n        serializedItem = String(index);\n        richValues.set(serializedItem, item);\n      } else {\n        serializedItem = String(item);\n      }\n      serializedValue.push(serializedItem);\n      index++;\n    }\n    return getFormattedValue(formatOrOptions, overrides, formats?.list,\n    // @ts-expect-error -- `richValues.size` is used to determine the return type, but TypeScript can't infer the meaning of this correctly\n    options => {\n      const result = formatters.getListFormat(locale, options).formatToParts(serializedValue).map(part => part.type === 'literal' ? part.value : richValues.get(part.value) || part.value);\n      if (richValues.size > 0) {\n        return result;\n      } else {\n        return result.join('');\n      }\n    }, () => String(value));\n  }\n  return {\n    dateTime,\n    number,\n    relativeTime,\n    list,\n    dateTimeRange\n  };\n}\nfunction validateMessagesSegment(messages, invalidKeyLabels, parentPath) {\n  Object.entries(messages).forEach(([key, messageOrMessages]) => {\n    if (key.includes('.')) {\n      let keyLabel = key;\n      if (parentPath) keyLabel += ` (at ${parentPath})`;\n      invalidKeyLabels.push(keyLabel);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (messageOrMessages != null && typeof messageOrMessages === 'object') {\n      validateMessagesSegment(messageOrMessages, invalidKeyLabels, joinPath(parentPath, key));\n    }\n  });\n}\nfunction validateMessages(messages, onError) {\n  const invalidKeyLabels = [];\n  validateMessagesSegment(messages, invalidKeyLabels);\n  if (invalidKeyLabels.length > 0) {\n    onError(new IntlError(IntlErrorCode.INVALID_KEY, `Namespace keys can not contain the character \".\" as this is used to express nesting. Please remove it or replace it with another character.\n\nInvalid ${invalidKeyLabels.length === 1 ? 'key' : 'keys'}: ${invalidKeyLabels.join(', ')}\n\nIf you're migrating from a flat structure, you can convert your messages as follows:\n\nimport {set} from \"lodash\";\n\nconst input = {\n  \"one.one\": \"1.1\",\n  \"one.two\": \"1.2\",\n  \"two.one.one\": \"2.1.1\"\n};\n\nconst output = Object.entries(input).reduce(\n  (acc, [key, value]) => set(acc, key, value),\n  {}\n);\n\n// Output:\n//\n// {\n//   \"one\": {\n//     \"one\": \"1.1\",\n//     \"two\": \"1.2\"\n//   },\n//   \"two\": {\n//     \"one\": {\n//       \"one\": \"2.1.1\"\n//     }\n//   }\n// }\n`));\n  }\n}\n\n/**\n * Enhances the incoming props with defaults.\n */\nfunction initializeConfig(_ref) {\n  let {\n      formats,\n      getMessageFallback,\n      messages,\n      onError\n    } = _ref,\n    rest = _objectWithoutProperties(_ref, _excluded);\n  const finalOnError = onError || defaultOnError;\n  const finalGetMessageFallback = getMessageFallback || defaultGetMessageFallback;\n  {\n    if (messages) {\n      validateMessages(messages, finalOnError);\n    }\n  }\n  return _objectSpread(_objectSpread({}, rest), {}, {\n    formats: formats || undefined,\n    messages: messages || undefined,\n    onError: finalOnError,\n    getMessageFallback: finalGetMessageFallback\n  });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL3VzZS1pbnRsL2Rpc3QvZXNtL2RldmVsb3BtZW50L2luaXRpYWxpemVDb25maWctRFBGbnZzVU8uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXVEO0FBQ0Y7QUFDUTtBQUU3RCxNQUFNSyxTQUFTLFNBQVNDLEtBQUssQ0FBQztFQUM1QkMsV0FBV0EsQ0FBQ0MsSUFBSSxFQUFFQyxlQUFlLEVBQUU7SUFDakMsSUFBSUMsT0FBTyxHQUFHRixJQUFJO0lBQ2xCLElBQUlDLGVBQWUsRUFBRTtNQUNuQkMsT0FBTyxJQUFJLElBQUksR0FBR0QsZUFBZTtJQUNuQztJQUNBLEtBQUssQ0FBQ0MsT0FBTyxDQUFDO0lBQ2QsSUFBSSxDQUFDRixJQUFJLEdBQUdBLElBQUk7SUFDaEIsSUFBSUMsZUFBZSxFQUFFO01BQ25CLElBQUksQ0FBQ0EsZUFBZSxHQUFHQSxlQUFlO0lBQ3hDO0VBQ0Y7QUFDRjtBQUVBLElBQUlFLGFBQWEsR0FBRyxhQUFhLFVBQVVBLGFBQWEsRUFBRTtFQUN4REEsYUFBYSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsaUJBQWlCO0VBQ3BEQSxhQUFhLENBQUMsZ0JBQWdCLENBQUMsR0FBRyxnQkFBZ0I7RUFDbERBLGFBQWEsQ0FBQyxzQkFBc0IsQ0FBQyxHQUFHLHNCQUFzQjtFQUM5REEsYUFBYSxDQUFDLG1CQUFtQixDQUFDLEdBQUcsbUJBQW1CO0VBQ3hEQSxhQUFhLENBQUMsaUJBQWlCLENBQUMsR0FBRyxpQkFBaUI7RUFDcERBLGFBQWEsQ0FBQyxhQUFhLENBQUMsR0FBRyxhQUFhO0VBQzVDQSxhQUFhLENBQUMsa0JBQWtCLENBQUMsR0FBRyxrQkFBa0I7RUFDdEQsT0FBT0EsYUFBYTtBQUN0QixDQUFDLENBQUNBLGFBQWEsSUFBSSxDQUFDLENBQUMsQ0FBQzs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTQyxpQ0FBaUNBLENBQUNDLGFBQWEs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S2tNLElBQUk7SUFDUHZNLE9BQU8sRUFBRUEsT0FBTyxJQUFJcUYsU0FBUztJQUM3QnJCLFFBQVEsRUFBRUEsUUFBUSxJQUFJcUIsU0FBUztJQUMvQlAsT0FBTyxFQUFFNEgsWUFBWTtJQUNyQmhILGtCQUFrQixFQUFFaUg7RUFBdUI7QUFFL0MiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQURNSU5cXE9uZURyaXZlXFxEZXNrdG9wXFxJbSBhIGJpcmRkZGRkZGRcXG5vZGVfbW9kdWxlc1xcdXNlLWludGxcXGRpc3RcXGVzbVxcZGV2ZWxvcG1lbnRcXGluaXRpYWxpemVDb25maWctRFBGbnZzVU8uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW50bE1lc3NhZ2VGb3JtYXQgfSBmcm9tICdpbnRsLW1lc3NhZ2Vmb3JtYXQnO1xuaW1wb3J0IHsgaXNWYWxpZEVsZW1lbnQsIGNsb25lRWxlbWVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IG1lbW9pemUsIHN0cmF0ZWdpZXMgfSBmcm9tICdAZm9ybWF0anMvZmFzdC1tZW1vaXplJztcblxuY2xhc3MgSW50bEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcihjb2RlLCBvcmlnaW5hbE1lc3NhZ2UpIHtcbiAgICBsZXQgbWVzc2FnZSA9IGNvZGU7XG4gICAgaWYgKG9yaWdpbmFsTWVzc2FnZSkge1xuICAgICAgbWVzc2FnZSArPSAnOiAnICsgb3JpZ2luYWxNZXNzYWdlO1xuICAgIH1cbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIGlmIChvcmlnaW5hbE1lc3NhZ2UpIHtcbiAgICAgIHRoaXMub3JpZ2luYWxNZXNzYWdlID0gb3JpZ2luYWxNZXNzYWdlO1xuICAgIH1cbiAgfVxufVxuXG52YXIgSW50bEVycm9yQ29kZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoSW50bEVycm9yQ29kZSkge1xuICBJbnRsRXJyb3JDb2RlW1wiTUlTU0lOR19NRVNTQUdFXCJdID0gXCJNSVNTSU5HX01FU1NBR0VcIjtcbiAgSW50bEVycm9yQ29kZVtcIk1JU1NJTkdfRk9STUFUXCJdID0gXCJNSVNTSU5HX0ZPUk1BVFwiO1xuICBJbnRsRXJyb3JDb2RlW1wiRU5WSVJPTk1FTlRfRkFMTEJBQ0tcIl0gPSBcIkVOVklST05NRU5UX0ZBTExCQUNLXCI7XG4gIEludGxFcnJvckNvZGVbXCJJTlNVRkZJQ0lFTlRfUEFUSFwiXSA9IFwiSU5TVUZGSUNJRU5UX1BBVEhcIjtcbiAgSW50bEVycm9yQ29kZVtcIklOVkFMSURfTUVTU0FHRVwiXSA9IFwiSU5WQUxJRF9NRVNTQUdFXCI7XG4gIEludGxFcnJvckNvZGVbXCJJTlZBTElEX0tFWVwiXSA9IFwiSU5WQUxJRF9LRVlcIjtcbiAgSW50bEVycm9yQ29kZVtcIkZPUk1BVFRJTkdfRVJST1JcIl0gPSBcIkZPUk1BVFRJTkdfRVJST1JcIjtcbiAgcmV0dXJuIEludGxFcnJvckNvZGU7XG59KEludGxFcnJvckNvZGUgfHwge30pO1xuXG4vKipcbiAqIGBpbnRsLW1lc3NhZ2Vmb3JtYXRgIHVzZXMgc2VwYXJhdGUga2V5cyBmb3IgYGRhdGVgIGFuZCBgdGltZWAsIGJ1dCB0aGVyZSdzXG4gKiBvbmx5IG9uZSBuYXRpdmUgQVBJOiBgSW50bC5EYXRlVGltZUZvcm1hdGAuIEFkZGl0aW9uYWxseSB5b3UgbWlnaHQgd2FudCB0b1xuICogaW5jbHVkZSBib3RoIGEgdGltZSBhbmQgYSBkYXRlIGluIGEgdmFsdWUsIHRoZXJlZm9yZSB0aGUgc2VwYXJhdGlvbiBkb2Vzbid0XG4gKiBzZWVtIHNvIHVzZWZ1bC4gV2Ugb2ZmZXIgYSBzaW5nbGUgYGRhdGVUaW1lYCBuYW1lc3BhY2UgaW5zdGVhZCwgYnV0IHdlIGhhdmVcbiAqIHRvIGNvbnZlcnQgdGhlIGZvcm1hdCBiZWZvcmUgYGludGwtbWVzc2FnZWZvcm1hdGAgY2FuIGJlIHVzZWQuXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRGb3JtYXRzVG9JbnRsTWVzc2FnZUZvcm1hdChnbG9iYWxGb3JtYXRzLCBpbmxpbmVGb3JtYXRzLCB0aW1lWm9uZSkge1xuICBjb25zdCBtZkRhdGVEZWZhdWx0cyA9IEludGxNZXNzYWdlRm9ybWF0LmZvcm1hdHMuZGF0ZTtcbiAgY29uc3QgbWZUaW1lRGVmYXVsdHMgPSBJbnRsTWVzc2FnZUZvcm1hdC5mb3JtYXRzLnRpbWU7XG4gIGNvbnN0IGRhdGVUaW1lRm9ybWF0cyA9IHtcbiAgICAuLi5nbG9iYWxGb3JtYXRzPy5kYXRlVGltZSxcbiAgICAuLi5pbmxpbmVGb3JtYXRzPy5kYXRlVGltZVxuICB9O1xuICBjb25zdCBhbGxGb3JtYXRzID0ge1xuICAgIGRhdGU6IHtcbiAgICAgIC4uLm1mRGF0ZURlZmF1bHRzLFxuICAgICAgLi4uZGF0ZVRpbWVGb3JtYXRzXG4gICAgfSxcbiAgICB0aW1lOiB7XG4gICAgICAuLi5tZlRpbWVEZWZhdWx0cyxcbiAgICAgIC4uLmRhdGVUaW1lRm9ybWF0c1xuICAgIH0sXG4gICAgbnVtYmVyOiB7XG4gICAgICAuLi5nbG9iYWxGb3JtYXRzPy5udW1iZXIsXG4gICAgICAuLi5pbmxpbmVGb3JtYXRzPy5udW1iZXJcbiAgICB9XG4gICAgLy8gKGxpc3QgaXMgbm90IHN1cHBvcnRlZCBpbiBJQ1UgbWVzc2FnZXMpXG4gIH07XG4gIGlmICh0aW1lWm9uZSkge1xuICAgIC8vIFRoZSBvbmx5IHdheSB0byBzZXQgYSB0aW1lIHpvbmUgd2l0aCBgaW50bC1tZXNzYWdlZm9ybWF0YCBpcyB0byBtZXJnZSBpdCBpbnRvIHRoZSBmb3JtYXRzXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zvcm1hdGpzL2Zvcm1hdGpzL2Jsb2IvODI1NmM1MjcxNTA1Y2YyNjA2ZTQ4ZTNjOTdlY2RkMTZlZGU0ZjFiNS9wYWNrYWdlcy9pbnRsL3NyYy9tZXNzYWdlLnRzI0wxNVxuICAgIFsnZGF0ZScsICd0aW1lJ10uZm9yRWFjaChwcm9wZXJ0eSA9PiB7XG4gICAgICBjb25zdCBmb3JtYXRzID0gYWxsRm9ybWF0c1twcm9wZXJ0eV07XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhmb3JtYXRzKSkge1xuICAgICAgICBmb3JtYXRzW2tleV0gPSB7XG4gICAgICAgICAgdGltZVpvbmUsXG4gICAgICAgICAgLi4udmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gYWxsRm9ybWF0cztcbn1cblxuZnVuY3Rpb24gam9pblBhdGgoLi4ucGFydHMpIHtcbiAgcmV0dXJuIHBhcnRzLmZpbHRlcihCb29sZWFuKS5qb2luKCcuJyk7XG59XG5cbi8qKlxuICogQ29udGFpbnMgZGVmYXVsdHMgdGhhdCBhcmUgdXNlZCBmb3IgYWxsIGVudHJ5IHBvaW50cyBpbnRvIHRoZSBjb3JlLlxuICogU2VlIGFsc28gYEluaXRpYWxpemVkSW50bENvbmZpZ3VyYXRpb25gLlxuICovXG5cbmZ1bmN0aW9uIGRlZmF1bHRHZXRNZXNzYWdlRmFsbGJhY2socHJvcHMpIHtcbiAgcmV0dXJuIGpvaW5QYXRoKHByb3BzLm5hbWVzcGFjZSwgcHJvcHMua2V5KTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRPbkVycm9yKGVycm9yKSB7XG4gIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDYWNoZSgpIHtcbiAgcmV0dXJuIHtcbiAgICBkYXRlVGltZToge30sXG4gICAgbnVtYmVyOiB7fSxcbiAgICBtZXNzYWdlOiB7fSxcbiAgICByZWxhdGl2ZVRpbWU6IHt9LFxuICAgIHBsdXJhbFJ1bGVzOiB7fSxcbiAgICBsaXN0OiB7fSxcbiAgICBkaXNwbGF5TmFtZXM6IHt9XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVNZW1vQ2FjaGUoc3RvcmUpIHtcbiAgcmV0dXJuIHtcbiAgICBjcmVhdGUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBnZXQoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIHN0b3JlW2tleV07XG4gICAgICAgIH0sXG4gICAgICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgc3RvcmVba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIG1lbW9GbihmbiwgY2FjaGUpIHtcbiAgcmV0dXJuIG1lbW9pemUoZm4sIHtcbiAgICBjYWNoZTogY3JlYXRlTWVtb0NhY2hlKGNhY2hlKSxcbiAgICBzdHJhdGVneTogc3RyYXRlZ2llcy52YXJpYWRpY1xuICB9KTtcbn1cbmZ1bmN0aW9uIG1lbW9Db25zdHJ1Y3RvcihDb25zdHJ1Y3RvckZuLCBjYWNoZSkge1xuICByZXR1cm4gbWVtb0ZuKCguLi5hcmdzKSA9PiBuZXcgQ29uc3RydWN0b3JGbiguLi5hcmdzKSwgY2FjaGUpO1xufVxuZnVuY3Rpb24gY3JlYXRlSW50bEZvcm1hdHRlcnMoY2FjaGUpIHtcbiAgY29uc3QgZ2V0RGF0ZVRpbWVGb3JtYXQgPSBtZW1vQ29uc3RydWN0b3IoSW50bC5EYXRlVGltZUZvcm1hdCwgY2FjaGUuZGF0ZVRpbWUpO1xuICBjb25zdCBnZXROdW1iZXJGb3JtYXQgPSBtZW1vQ29uc3RydWN0b3IoSW50bC5OdW1iZXJGb3JtYXQsIGNhY2hlLm51bWJlcik7XG4gIGNvbnN0IGdldFBsdXJhbFJ1bGVzID0gbWVtb0NvbnN0cnVjdG9yKEludGwuUGx1cmFsUnVsZXMsIGNhY2hlLnBsdXJhbFJ1bGVzKTtcbiAgY29uc3QgZ2V0UmVsYXRpdmVUaW1lRm9ybWF0ID0gbWVtb0NvbnN0cnVjdG9yKEludGwuUmVsYXRpdmVUaW1lRm9ybWF0LCBjYWNoZS5yZWxhdGl2ZVRpbWUpO1xuICBjb25zdCBnZXRMaXN0Rm9ybWF0ID0gbWVtb0NvbnN0cnVjdG9yKEludGwuTGlzdEZvcm1hdCwgY2FjaGUubGlzdCk7XG4gIGNvbnN0IGdldERpc3BsYXlOYW1lcyA9IG1lbW9Db25zdHJ1Y3RvcihJbnRsLkRpc3BsYXlOYW1lcywgY2FjaGUuZGlzcGxheU5hbWVzKTtcbiAgcmV0dXJuIHtcbiAgICBnZXREYXRlVGltZUZvcm1hdCxcbiAgICBnZXROdW1iZXJGb3JtYXQsXG4gICAgZ2V0UGx1cmFsUnVsZXMsXG4gICAgZ2V0UmVsYXRpdmVUaW1lRm9ybWF0LFxuICAgIGdldExpc3RGb3JtYXQsXG4gICAgZ2V0RGlzcGxheU5hbWVzXG4gIH07XG59XG5cbi8vIFBsYWNlZCBoZXJlIGZvciBpbXByb3ZlZCB0cmVlIHNoYWtpbmcuIFNvbWVob3cgd2hlbiB0aGlzIGlzIHBsYWNlZCBpblxuLy8gYGZvcm1hdHRlcnMudHN4YCwgdGhlbiBpdCBjYW4ndCBiZSBzaGFrZW4gb2ZmIGZyb20gYG5leHQtaW50bGAuXG5mdW5jdGlvbiBjcmVhdGVNZXNzYWdlRm9ybWF0dGVyKGNhY2hlLCBpbnRsRm9ybWF0dGVycykge1xuICBjb25zdCBnZXRNZXNzYWdlRm9ybWF0ID0gbWVtb0ZuKCguLi5hcmdzKSA9PiBuZXcgSW50bE1lc3NhZ2VGb3JtYXQoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwge1xuICAgIGZvcm1hdHRlcnM6IGludGxGb3JtYXR0ZXJzLFxuICAgIC4uLmFyZ3NbM11cbiAgfSksIGNhY2hlLm1lc3NhZ2UpO1xuICByZXR1cm4gZ2V0TWVzc2FnZUZvcm1hdDtcbn1cbmZ1bmN0aW9uIHJlc29sdmVQYXRoKGxvY2FsZSwgbWVzc2FnZXMsIGtleSwgbmFtZXNwYWNlKSB7XG4gIGNvbnN0IGZ1bGxLZXkgPSBqb2luUGF0aChuYW1lc3BhY2UsIGtleSk7XG4gIGlmICghbWVzc2FnZXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIG1lc3NhZ2VzIGF2YWlsYWJsZSBhdCBcXGAke25hbWVzcGFjZX1cXGAuYCApO1xuICB9XG4gIGxldCBtZXNzYWdlID0gbWVzc2FnZXM7XG4gIGtleS5zcGxpdCgnLicpLmZvckVhY2gocGFydCA9PiB7XG4gICAgY29uc3QgbmV4dCA9IG1lc3NhZ2VbcGFydF07XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuICAgIGlmIChwYXJ0ID09IG51bGwgfHwgbmV4dCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCByZXNvbHZlIFxcYCR7ZnVsbEtleX1cXGAgaW4gbWVzc2FnZXMgZm9yIGxvY2FsZSBcXGAke2xvY2FsZX1cXGAuYCApO1xuICAgIH1cbiAgICBtZXNzYWdlID0gbmV4dDtcbiAgfSk7XG4gIHJldHVybiBtZXNzYWdlO1xufVxuZnVuY3Rpb24gcHJlcGFyZVRyYW5zbGF0aW9uVmFsdWVzKHZhbHVlcykge1xuICAvLyBXb3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vZm9ybWF0anMvZm9ybWF0anMvaXNzdWVzLzE0NjdcbiAgY29uc3QgdHJhbnNmb3JtZWRWYWx1ZXMgPSB7fTtcbiAgT2JqZWN0LmtleXModmFsdWVzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1trZXldO1xuICAgIGxldCB0cmFuc2Zvcm1lZDtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0cmFuc2Zvcm1lZCA9IGNodW5rcyA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbHVlKGNodW5rcyk7XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovaXNWYWxpZEVsZW1lbnQocmVzdWx0KSA/IC8qI19fUFVSRV9fKi9jbG9uZUVsZW1lbnQocmVzdWx0LCB7XG4gICAgICAgICAga2V5OiBrZXkgKyBpbmRleCsrXG4gICAgICAgIH0pIDogcmVzdWx0O1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhbnNmb3JtZWQgPSB2YWx1ZTtcbiAgICB9XG4gICAgdHJhbnNmb3JtZWRWYWx1ZXNba2V5XSA9IHRyYW5zZm9ybWVkO1xuICB9KTtcbiAgcmV0dXJuIHRyYW5zZm9ybWVkVmFsdWVzO1xufVxuZnVuY3Rpb24gZ2V0TWVzc2FnZXNPckVycm9yKGxvY2FsZSwgbWVzc2FnZXMsIG5hbWVzcGFjZSwgb25FcnJvciA9IGRlZmF1bHRPbkVycm9yKSB7XG4gIHRyeSB7XG4gICAgaWYgKCFtZXNzYWdlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBtZXNzYWdlcyB3ZXJlIGNvbmZpZ3VyZWQuYCApO1xuICAgIH1cbiAgICBjb25zdCByZXRyaWV2ZWRNZXNzYWdlcyA9IG5hbWVzcGFjZSA/IHJlc29sdmVQYXRoKGxvY2FsZSwgbWVzc2FnZXMsIG5hbWVzcGFjZSkgOiBtZXNzYWdlcztcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG4gICAgaWYgKCFyZXRyaWV2ZWRNZXNzYWdlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBtZXNzYWdlcyBmb3IgbmFtZXNwYWNlIFxcYCR7bmFtZXNwYWNlfVxcYCBmb3VuZC5gICk7XG4gICAgfVxuICAgIHJldHVybiByZXRyaWV2ZWRNZXNzYWdlcztcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zdCBpbnRsRXJyb3IgPSBuZXcgSW50bEVycm9yKEludGxFcnJvckNvZGUuTUlTU0lOR19NRVNTQUdFLCBlcnJvci5tZXNzYWdlKTtcbiAgICBvbkVycm9yKGludGxFcnJvcik7XG4gICAgcmV0dXJuIGludGxFcnJvcjtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0UGxhaW5NZXNzYWdlKGNhbmRpZGF0ZSwgdmFsdWVzKSB7XG4gIC8vIFRvIGltcHJvdmUgcnVudGltZSBwZXJmb3JtYW5jZSwgb25seSBjb21waWxlIG1lc3NhZ2UgaWY6XG4gIHJldHVybiAoXG4gICAgLy8gMS4gVmFsdWVzIGFyZSBwcm92aWRlZFxuICAgIHZhbHVlcyB8fFxuICAgIC8vIDIuIFRoZXJlIGFyZSBlc2NhcGVkIGJyYWNlcyAoZS5nLiBcIid7bmFtZSd9XCIpXG4gICAgLydbe31dLy50ZXN0KGNhbmRpZGF0ZSkgfHxcbiAgICAvLyAzLiBUaGVyZSBhcmUgbWlzc2luZyBhcmd1bWVudHMgb3IgdGFncyAoZGV2LW9ubHkgZXJyb3IgaGFuZGxpbmcpXG4gICAgLzx8ey8udGVzdChjYW5kaWRhdGUpID8gdW5kZWZpbmVkIC8vIENvbXBpbGVcbiAgICA6IGNhbmRpZGF0ZSAvLyBEb24ndCBjb21waWxlXG4gICk7XG59XG5mdW5jdGlvbiBjcmVhdGVCYXNlVHJhbnNsYXRvcihjb25maWcpIHtcbiAgY29uc3QgbWVzc2FnZXNPckVycm9yID0gZ2V0TWVzc2FnZXNPckVycm9yKGNvbmZpZy5sb2NhbGUsIGNvbmZpZy5tZXNzYWdlcywgY29uZmlnLm5hbWVzcGFjZSwgY29uZmlnLm9uRXJyb3IpO1xuICByZXR1cm4gY3JlYXRlQmFzZVRyYW5zbGF0b3JJbXBsKHtcbiAgICAuLi5jb25maWcsXG4gICAgbWVzc2FnZXNPckVycm9yXG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlQmFzZVRyYW5zbGF0b3JJbXBsKHtcbiAgY2FjaGUsXG4gIGZvcm1hdHM6IGdsb2JhbEZvcm1hdHMsXG4gIGZvcm1hdHRlcnMsXG4gIGdldE1lc3NhZ2VGYWxsYmFjayA9IGRlZmF1bHRHZXRNZXNzYWdlRmFsbGJhY2ssXG4gIGxvY2FsZSxcbiAgbWVzc2FnZXNPckVycm9yLFxuICBuYW1lc3BhY2UsXG4gIG9uRXJyb3IsXG4gIHRpbWVab25lXG59KSB7XG4gIGNvbnN0IGhhc01lc3NhZ2VzRXJyb3IgPSBtZXNzYWdlc09yRXJyb3IgaW5zdGFuY2VvZiBJbnRsRXJyb3I7XG4gIGZ1bmN0aW9uIGdldEZhbGxiYWNrRnJvbUVycm9yQW5kTm90aWZ5KGtleSwgY29kZSwgbWVzc2FnZSkge1xuICAgIGNvbnN0IGVycm9yID0gbmV3IEludGxFcnJvcihjb2RlLCBtZXNzYWdlKTtcbiAgICBvbkVycm9yKGVycm9yKTtcbiAgICByZXR1cm4gZ2V0TWVzc2FnZUZhbGxiYWNrKHtcbiAgICAgIGVycm9yLFxuICAgICAga2V5LFxuICAgICAgbmFtZXNwYWNlXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gdHJhbnNsYXRlQmFzZUZuKC8qKiBVc2UgYSBkb3QgdG8gaW5kaWNhdGUgYSBsZXZlbCBvZiBuZXN0aW5nIChlLmcuIGBuYW1lc3BhY2UubmVzdGVkTGFiZWxgKS4gKi9cbiAga2V5LCAvKiogS2V5IHZhbHVlIHBhaXJzIGZvciB2YWx1ZXMgdG8gaW50ZXJwb2xhdGUgaW50byB0aGUgbWVzc2FnZS4gKi9cbiAgdmFsdWVzLCAvKiogUHJvdmlkZSBjdXN0b20gZm9ybWF0cyBmb3IgbnVtYmVycywgZGF0ZXMgYW5kIHRpbWVzLiAqL1xuICBmb3JtYXRzKSB7XG4gICAgaWYgKGhhc01lc3NhZ2VzRXJyb3IpIHtcbiAgICAgIC8vIFdlIGhhdmUgYWxyZWFkeSB3YXJuZWQgYWJvdXQgdGhpcyBkdXJpbmcgcmVuZGVyXG4gICAgICByZXR1cm4gZ2V0TWVzc2FnZUZhbGxiYWNrKHtcbiAgICAgICAgZXJyb3I6IG1lc3NhZ2VzT3JFcnJvcixcbiAgICAgICAga2V5LFxuICAgICAgICBuYW1lc3BhY2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlcyA9IG1lc3NhZ2VzT3JFcnJvcjtcbiAgICBsZXQgbWVzc2FnZTtcbiAgICB0cnkge1xuICAgICAgbWVzc2FnZSA9IHJlc29sdmVQYXRoKGxvY2FsZSwgbWVzc2FnZXMsIGtleSwgbmFtZXNwYWNlKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIGdldEZhbGxiYWNrRnJvbUVycm9yQW5kTm90aWZ5KGtleSwgSW50bEVycm9yQ29kZS5NSVNTSU5HX01FU1NBR0UsIGVycm9yLm1lc3NhZ2UpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdvYmplY3QnKSB7XG4gICAgICBsZXQgY29kZSwgZXJyb3JNZXNzYWdlO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWVzc2FnZSkpIHtcbiAgICAgICAgY29kZSA9IEludGxFcnJvckNvZGUuSU5WQUxJRF9NRVNTQUdFO1xuICAgICAgICB7XG4gICAgICAgICAgZXJyb3JNZXNzYWdlID0gYE1lc3NhZ2UgYXQgXFxgJHtqb2luUGF0aChuYW1lc3BhY2UsIGtleSl9XFxgIHJlc29sdmVkIHRvIGFuIGFycmF5LCBidXQgb25seSBzdHJpbmdzIGFyZSBzdXBwb3J0ZWQuIFNlZSBodHRwczovL25leHQtaW50bC5kZXYvZG9jcy91c2FnZS9tZXNzYWdlcyNhcnJheXMtb2YtbWVzc2FnZXNgO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb2RlID0gSW50bEVycm9yQ29kZS5JTlNVRkZJQ0lFTlRfUEFUSDtcbiAgICAgICAge1xuICAgICAgICAgIGVycm9yTWVzc2FnZSA9IGBNZXNzYWdlIGF0IFxcYCR7am9pblBhdGgobmFtZXNwYWNlLCBrZXkpfVxcYCByZXNvbHZlZCB0byBhbiBvYmplY3QsIGJ1dCBvbmx5IHN0cmluZ3MgYXJlIHN1cHBvcnRlZC4gVXNlIGEgXFxgLlxcYCB0byByZXRyaWV2ZSBuZXN0ZWQgbWVzc2FnZXMuIFNlZSBodHRwczovL25leHQtaW50bC5kZXYvZG9jcy91c2FnZS9tZXNzYWdlcyNzdHJ1Y3R1cmluZy1tZXNzYWdlc2A7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRGYWxsYmFja0Zyb21FcnJvckFuZE5vdGlmeShrZXksIGNvZGUsIGVycm9yTWVzc2FnZSk7XG4gICAgfVxuICAgIGxldCBtZXNzYWdlRm9ybWF0O1xuXG4gICAgLy8gSG90IHBhdGggdGhhdCBhdm9pZHMgY3JlYXRpbmcgYW4gYEludGxNZXNzYWdlRm9ybWF0YCBpbnN0YW5jZVxuICAgIGNvbnN0IHBsYWluTWVzc2FnZSA9IGdldFBsYWluTWVzc2FnZShtZXNzYWdlLCB2YWx1ZXMpO1xuICAgIGlmIChwbGFpbk1lc3NhZ2UpIHJldHVybiBwbGFpbk1lc3NhZ2U7XG5cbiAgICAvLyBMYXp5IGluaXQgdGhlIG1lc3NhZ2UgZm9ybWF0dGVyIGZvciBiZXR0ZXIgdHJlZVxuICAgIC8vIHNoYWtpbmcgaW4gY2FzZSBtZXNzYWdlIGZvcm1hdHRpbmcgaXMgbm90IHVzZWQuXG4gICAgaWYgKCFmb3JtYXR0ZXJzLmdldE1lc3NhZ2VGb3JtYXQpIHtcbiAgICAgIGZvcm1hdHRlcnMuZ2V0TWVzc2FnZUZvcm1hdCA9IGNyZWF0ZU1lc3NhZ2VGb3JtYXR0ZXIoY2FjaGUsIGZvcm1hdHRlcnMpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgbWVzc2FnZUZvcm1hdCA9IGZvcm1hdHRlcnMuZ2V0TWVzc2FnZUZvcm1hdChtZXNzYWdlLCBsb2NhbGUsIGNvbnZlcnRGb3JtYXRzVG9JbnRsTWVzc2FnZUZvcm1hdChnbG9iYWxGb3JtYXRzLCBmb3JtYXRzLCB0aW1lWm9uZSksIHtcbiAgICAgICAgZm9ybWF0dGVyczoge1xuICAgICAgICAgIC4uLmZvcm1hdHRlcnMsXG4gICAgICAgICAgZ2V0RGF0ZVRpbWVGb3JtYXQobG9jYWxlcywgb3B0aW9ucykge1xuICAgICAgICAgICAgLy8gV29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL2Zvcm1hdGpzL2Zvcm1hdGpzL2lzc3Vlcy80Mjc5XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0dGVycy5nZXREYXRlVGltZUZvcm1hdChsb2NhbGVzLCB7XG4gICAgICAgICAgICAgIHRpbWVab25lLFxuICAgICAgICAgICAgICAuLi5vcHRpb25zXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zdCB0aHJvd25FcnJvciA9IGVycm9yO1xuICAgICAgcmV0dXJuIGdldEZhbGxiYWNrRnJvbUVycm9yQW5kTm90aWZ5KGtleSwgSW50bEVycm9yQ29kZS5JTlZBTElEX01FU1NBR0UsIHRocm93bkVycm9yLm1lc3NhZ2UgKyAoJ29yaWdpbmFsTWVzc2FnZScgaW4gdGhyb3duRXJyb3IgPyBgICgke3Rocm93bkVycm9yLm9yaWdpbmFsTWVzc2FnZX0pYCA6ICcnKSApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgZm9ybWF0dGVkTWVzc2FnZSA9IG1lc3NhZ2VGb3JtYXQuZm9ybWF0KFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBgaW50bC1tZXNzYWdlZm9ybWF0YCBleHBlY3RzIGEgZGlmZmVyZW50IGZvcm1hdFxuICAgICAgLy8gZm9yIHJpY2ggdGV4dCBlbGVtZW50cyBzaW5jZSBhIHJlY2VudCBtaW5vciB1cGRhdGUuIFRoaXNcbiAgICAgIC8vIG5lZWRzIHRvIGJlIGV2YWx1YXRlZCBpbiBkZXRhaWwsIHBvc3NpYmx5IGFsc28gaW4gcmVnYXJkc1xuICAgICAgLy8gdG8gYmUgYWJsZSB0byBmb3JtYXQgdG8gcGFydHMuXG4gICAgICB2YWx1ZXMgPyBwcmVwYXJlVHJhbnNsYXRpb25WYWx1ZXModmFsdWVzKSA6IHZhbHVlcyk7XG4gICAgICBpZiAoZm9ybWF0dGVkTWVzc2FnZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGZvcm1hdCBcXGAke2tleX1cXGAgaW4gJHtuYW1lc3BhY2UgPyBgbmFtZXNwYWNlIFxcYCR7bmFtZXNwYWNlfVxcYGAgOiAnbWVzc2FnZXMnfWAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gTGltaXQgdGhlIGZ1bmN0aW9uIHNpZ25hdHVyZSB0byByZXR1cm4gc3RyaW5ncyBvciBSZWFjdCBlbGVtZW50c1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9pc1ZhbGlkRWxlbWVudChmb3JtYXR0ZWRNZXNzYWdlKSB8fFxuICAgICAgLy8gQXJyYXlzIG9mIFJlYWN0IGVsZW1lbnRzXG4gICAgICBBcnJheS5pc0FycmF5KGZvcm1hdHRlZE1lc3NhZ2UpIHx8IHR5cGVvZiBmb3JtYXR0ZWRNZXNzYWdlID09PSAnc3RyaW5nJyA/IGZvcm1hdHRlZE1lc3NhZ2UgOiBTdHJpbmcoZm9ybWF0dGVkTWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBnZXRGYWxsYmFja0Zyb21FcnJvckFuZE5vdGlmeShrZXksIEludGxFcnJvckNvZGUuRk9STUFUVElOR19FUlJPUiwgZXJyb3IubWVzc2FnZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHRyYW5zbGF0ZUZuKC8qKiBVc2UgYSBkb3QgdG8gaW5kaWNhdGUgYSBsZXZlbCBvZiBuZXN0aW5nIChlLmcuIGBuYW1lc3BhY2UubmVzdGVkTGFiZWxgKS4gKi9cbiAga2V5LCAvKiogS2V5IHZhbHVlIHBhaXJzIGZvciB2YWx1ZXMgdG8gaW50ZXJwb2xhdGUgaW50byB0aGUgbWVzc2FnZS4gKi9cbiAgdmFsdWVzLCAvKiogUHJvdmlkZSBjdXN0b20gZm9ybWF0cyBmb3IgbnVtYmVycywgZGF0ZXMgYW5kIHRpbWVzLiAqL1xuICBmb3JtYXRzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdHJhbnNsYXRlQmFzZUZuKGtleSwgdmFsdWVzLCBmb3JtYXRzKTtcbiAgICBpZiAodHlwZW9mIHJlc3VsdCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBnZXRGYWxsYmFja0Zyb21FcnJvckFuZE5vdGlmeShrZXksIEludGxFcnJvckNvZGUuSU5WQUxJRF9NRVNTQUdFLCBgVGhlIG1lc3NhZ2UgXFxgJHtrZXl9XFxgIGluICR7bmFtZXNwYWNlID8gYG5hbWVzcGFjZSBcXGAke25hbWVzcGFjZX1cXGBgIDogJ21lc3NhZ2VzJ30gZGlkbid0IHJlc29sdmUgdG8gYSBzdHJpbmcuIElmIHlvdSB3YW50IHRvIGZvcm1hdCByaWNoIHRleHQsIHVzZSBcXGB0LnJpY2hcXGAgaW5zdGVhZC5gICk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgdHJhbnNsYXRlRm4ucmljaCA9IHRyYW5zbGF0ZUJhc2VGbjtcblxuICAvLyBBdWdtZW50IGB0cmFuc2xhdGVCYXNlRm5gIHRvIHJldHVybiBwbGFpbiBzdHJpbmdzXG4gIHRyYW5zbGF0ZUZuLm1hcmt1cCA9IChrZXksIHZhbHVlcywgZm9ybWF0cykgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRyYW5zbGF0ZUJhc2VGbihrZXksXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtLSBgTWFya3VwVHJhbnNsYXRpb25WYWx1ZXNgIGlzIHByYWN0aWNhbGx5IGEgc3ViIHR5cGVcbiAgICAvLyBvZiBgUmljaFRyYW5zbGF0aW9uVmFsdWVzYCBidXQgVHlwZVNjcmlwdCBpc24ndCBzbWFydCBlbm91Z2ggaGVyZS5cbiAgICB2YWx1ZXMsIGZvcm1hdHMpO1xuICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgSW50bEVycm9yKEludGxFcnJvckNvZGUuRk9STUFUVElOR19FUlJPUiwgXCJgdC5tYXJrdXBgIG9ubHkgYWNjZXB0cyBmdW5jdGlvbnMgZm9yIGZvcm1hdHRpbmcgdGhhdCByZWNlaXZlIGFuZCByZXR1cm4gc3RyaW5ncy5cXG5cXG5FLmcuIHQubWFya3VwKCdtYXJrdXAnLCB7YjogKGNodW5rcykgPT4gYDxiPiR7Y2h1bmtzfTwvYj5gfSlcIik7XG4gICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgIHJldHVybiBnZXRNZXNzYWdlRmFsbGJhY2soe1xuICAgICAgICBlcnJvcixcbiAgICAgICAga2V5LFxuICAgICAgICBuYW1lc3BhY2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICB0cmFuc2xhdGVGbi5yYXcgPSBrZXkgPT4ge1xuICAgIGlmIChoYXNNZXNzYWdlc0Vycm9yKSB7XG4gICAgICAvLyBXZSBoYXZlIGFscmVhZHkgd2FybmVkIGFib3V0IHRoaXMgZHVyaW5nIHJlbmRlclxuICAgICAgcmV0dXJuIGdldE1lc3NhZ2VGYWxsYmFjayh7XG4gICAgICAgIGVycm9yOiBtZXNzYWdlc09yRXJyb3IsXG4gICAgICAgIGtleSxcbiAgICAgICAgbmFtZXNwYWNlXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZXMgPSBtZXNzYWdlc09yRXJyb3I7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiByZXNvbHZlUGF0aChsb2NhbGUsIG1lc3NhZ2VzLCBrZXksIG5hbWVzcGFjZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBnZXRGYWxsYmFja0Zyb21FcnJvckFuZE5vdGlmeShrZXksIEludGxFcnJvckNvZGUuTUlTU0lOR19NRVNTQUdFLCBlcnJvci5tZXNzYWdlKTtcbiAgICB9XG4gIH07XG4gIHRyYW5zbGF0ZUZuLmhhcyA9IGtleSA9PiB7XG4gICAgaWYgKGhhc01lc3NhZ2VzRXJyb3IpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJlc29sdmVQYXRoKGxvY2FsZSwgbWVzc2FnZXNPckVycm9yLCBrZXksIG5hbWVzcGFjZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG4gIHJldHVybiB0cmFuc2xhdGVGbjtcbn1cblxuLyoqXG4gKiBGb3IgdGhlIHN0cmljdGx5IHR5cGVkIG1lc3NhZ2VzIHRvIHdvcmsgd2UgaGF2ZSB0byB3cmFwIHRoZSBuYW1lc3BhY2UgaW50b1xuICogYSBtYW5kYXRvcnkgcHJlZml4LiBTZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzcxNTI5NTc1LzM0MzA0NVxuICovXG5mdW5jdGlvbiByZXNvbHZlTmFtZXNwYWNlKG5hbWVzcGFjZSwgbmFtZXNwYWNlUHJlZml4KSB7XG4gIHJldHVybiBuYW1lc3BhY2UgPT09IG5hbWVzcGFjZVByZWZpeCA/IHVuZGVmaW5lZCA6IG5hbWVzcGFjZS5zbGljZSgobmFtZXNwYWNlUHJlZml4ICsgJy4nKS5sZW5ndGgpO1xufVxuXG5jb25zdCBTRUNPTkQgPSAxO1xuY29uc3QgTUlOVVRFID0gU0VDT05EICogNjA7XG5jb25zdCBIT1VSID0gTUlOVVRFICogNjA7XG5jb25zdCBEQVkgPSBIT1VSICogMjQ7XG5jb25zdCBXRUVLID0gREFZICogNztcbmNvbnN0IE1PTlRIID0gREFZICogKDM2NSAvIDEyKTsgLy8gQXBwcm94aW1hdGlvblxuY29uc3QgUVVBUlRFUiA9IE1PTlRIICogMztcbmNvbnN0IFlFQVIgPSBEQVkgKiAzNjU7XG5jb25zdCBVTklUX1NFQ09ORFMgPSB7XG4gIHNlY29uZDogU0VDT05ELFxuICBzZWNvbmRzOiBTRUNPTkQsXG4gIG1pbnV0ZTogTUlOVVRFLFxuICBtaW51dGVzOiBNSU5VVEUsXG4gIGhvdXI6IEhPVVIsXG4gIGhvdXJzOiBIT1VSLFxuICBkYXk6IERBWSxcbiAgZGF5czogREFZLFxuICB3ZWVrOiBXRUVLLFxuICB3ZWVrczogV0VFSyxcbiAgbW9udGg6IE1PTlRILFxuICBtb250aHM6IE1PTlRILFxuICBxdWFydGVyOiBRVUFSVEVSLFxuICBxdWFydGVyczogUVVBUlRFUixcbiAgeWVhcjogWUVBUixcbiAgeWVhcnM6IFlFQVJcbn07XG5mdW5jdGlvbiByZXNvbHZlUmVsYXRpdmVUaW1lVW5pdChzZWNvbmRzKSB7XG4gIGNvbnN0IGFic1ZhbHVlID0gTWF0aC5hYnMoc2Vjb25kcyk7XG4gIGlmIChhYnNWYWx1ZSA8IE1JTlVURSkge1xuICAgIHJldHVybiAnc2Vjb25kJztcbiAgfSBlbHNlIGlmIChhYnNWYWx1ZSA8IEhPVVIpIHtcbiAgICByZXR1cm4gJ21pbnV0ZSc7XG4gIH0gZWxzZSBpZiAoYWJzVmFsdWUgPCBEQVkpIHtcbiAgICByZXR1cm4gJ2hvdXInO1xuICB9IGVsc2UgaWYgKGFic1ZhbHVlIDwgV0VFSykge1xuICAgIHJldHVybiAnZGF5JztcbiAgfSBlbHNlIGlmIChhYnNWYWx1ZSA8IE1PTlRIKSB7XG4gICAgcmV0dXJuICd3ZWVrJztcbiAgfSBlbHNlIGlmIChhYnNWYWx1ZSA8IFlFQVIpIHtcbiAgICByZXR1cm4gJ21vbnRoJztcbiAgfVxuICByZXR1cm4gJ3llYXInO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlUmVsYXRpdmVUaW1lVmFsdWUoc2Vjb25kcywgdW5pdCkge1xuICAvLyBXZSBoYXZlIHRvIHJvdW5kIHRoZSByZXN1bHRpbmcgdmFsdWVzLCBhcyBgSW50bC5SZWxhdGl2ZVRpbWVGb3JtYXRgXG4gIC8vIHdpbGwgaW5jbHVkZSBmcmFjdGlvbnMgbGlrZSAnMi4xIGhvdXJzIGFnbycuXG4gIHJldHVybiBNYXRoLnJvdW5kKHNlY29uZHMgLyBVTklUX1NFQ09ORFNbdW5pdF0pO1xufVxuZnVuY3Rpb24gY3JlYXRlRm9ybWF0dGVyKHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBfY2FjaGU6IGNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcbiAgICBfZm9ybWF0dGVyczogZm9ybWF0dGVycyA9IGNyZWF0ZUludGxGb3JtYXR0ZXJzKGNhY2hlKSxcbiAgICBmb3JtYXRzLFxuICAgIGxvY2FsZSxcbiAgICBvbkVycm9yID0gZGVmYXVsdE9uRXJyb3IsXG4gICAgdGltZVpvbmU6IGdsb2JhbFRpbWVab25lXG4gIH0gPSBwcm9wcztcbiAgZnVuY3Rpb24gYXBwbHlUaW1lWm9uZShvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zPy50aW1lWm9uZSkge1xuICAgICAgaWYgKGdsb2JhbFRpbWVab25lKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICB0aW1lWm9uZTogZ2xvYmFsVGltZVpvbmVcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uRXJyb3IobmV3IEludGxFcnJvcihJbnRsRXJyb3JDb2RlLkVOVklST05NRU5UX0ZBTExCQUNLLCBgVGhlIFxcYHRpbWVab25lXFxgIHBhcmFtZXRlciB3YXNuJ3QgcHJvdmlkZWQgYW5kIHRoZXJlIGlzIG5vIGdsb2JhbCBkZWZhdWx0IGNvbmZpZ3VyZWQuIENvbnNpZGVyIGFkZGluZyBhIGdsb2JhbCBkZWZhdWx0IHRvIGF2b2lkIG1hcmt1cCBtaXNtYXRjaGVzIGNhdXNlZCBieSBlbnZpcm9ubWVudCBkaWZmZXJlbmNlcy4gTGVhcm4gbW9yZTogaHR0cHM6Ly9uZXh0LWludGwuZGV2L2RvY3MvY29uZmlndXJhdGlvbiN0aW1lLXpvbmVgICkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfVxuICBmdW5jdGlvbiByZXNvbHZlRm9ybWF0T3JPcHRpb25zKHR5cGVGb3JtYXRzLCBmb3JtYXRPck9wdGlvbnMsIG92ZXJyaWRlcykge1xuICAgIGxldCBvcHRpb25zO1xuICAgIGlmICh0eXBlb2YgZm9ybWF0T3JPcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgZm9ybWF0TmFtZSA9IGZvcm1hdE9yT3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSB0eXBlRm9ybWF0cz8uW2Zvcm1hdE5hbWVdO1xuICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEludGxFcnJvcihJbnRsRXJyb3JDb2RlLk1JU1NJTkdfRk9STUFULCBgRm9ybWF0IFxcYCR7Zm9ybWF0TmFtZX1cXGAgaXMgbm90IGF2YWlsYWJsZS5gICk7XG4gICAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucyA9IGZvcm1hdE9yT3B0aW9ucztcbiAgICB9XG4gICAgaWYgKG92ZXJyaWRlcykge1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgLi4ub3ZlcnJpZGVzXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfVxuICBmdW5jdGlvbiBnZXRGb3JtYXR0ZWRWYWx1ZShmb3JtYXRPck9wdGlvbnMsIG92ZXJyaWRlcywgdHlwZUZvcm1hdHMsIGZvcm1hdHRlciwgZ2V0RmFsbGJhY2spIHtcbiAgICBsZXQgb3B0aW9ucztcbiAgICB0cnkge1xuICAgICAgb3B0aW9ucyA9IHJlc29sdmVGb3JtYXRPck9wdGlvbnModHlwZUZvcm1hdHMsIGZvcm1hdE9yT3B0aW9ucywgb3ZlcnJpZGVzKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBnZXRGYWxsYmFjaygpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZvcm1hdHRlcihvcHRpb25zKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgb25FcnJvcihuZXcgSW50bEVycm9yKEludGxFcnJvckNvZGUuRk9STUFUVElOR19FUlJPUiwgZXJyb3IubWVzc2FnZSkpO1xuICAgICAgcmV0dXJuIGdldEZhbGxiYWNrKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGRhdGVUaW1lKHZhbHVlLCBmb3JtYXRPck9wdGlvbnMsIG92ZXJyaWRlcykge1xuICAgIHJldHVybiBnZXRGb3JtYXR0ZWRWYWx1ZShmb3JtYXRPck9wdGlvbnMsIG92ZXJyaWRlcywgZm9ybWF0cz8uZGF0ZVRpbWUsIG9wdGlvbnMgPT4ge1xuICAgICAgb3B0aW9ucyA9IGFwcGx5VGltZVpvbmUob3B0aW9ucyk7XG4gICAgICByZXR1cm4gZm9ybWF0dGVycy5nZXREYXRlVGltZUZvcm1hdChsb2NhbGUsIG9wdGlvbnMpLmZvcm1hdCh2YWx1ZSk7XG4gICAgfSwgKCkgPT4gU3RyaW5nKHZhbHVlKSk7XG4gIH1cbiAgZnVuY3Rpb24gZGF0ZVRpbWVSYW5nZShzdGFydCwgZW5kLCBmb3JtYXRPck9wdGlvbnMsIG92ZXJyaWRlcykge1xuICAgIHJldHVybiBnZXRGb3JtYXR0ZWRWYWx1ZShmb3JtYXRPck9wdGlvbnMsIG92ZXJyaWRlcywgZm9ybWF0cz8uZGF0ZVRpbWUsIG9wdGlvbnMgPT4ge1xuICAgICAgb3B0aW9ucyA9IGFwcGx5VGltZVpvbmUob3B0aW9ucyk7XG4gICAgICByZXR1cm4gZm9ybWF0dGVycy5nZXREYXRlVGltZUZvcm1hdChsb2NhbGUsIG9wdGlvbnMpLmZvcm1hdFJhbmdlKHN0YXJ0LCBlbmQpO1xuICAgIH0sICgpID0+IFtkYXRlVGltZShzdGFydCksIGRhdGVUaW1lKGVuZCldLmpvaW4oJ+KAieKAk+KAiScpKTtcbiAgfVxuICBmdW5jdGlvbiBudW1iZXIodmFsdWUsIGZvcm1hdE9yT3B0aW9ucywgb3ZlcnJpZGVzKSB7XG4gICAgcmV0dXJuIGdldEZvcm1hdHRlZFZhbHVlKGZvcm1hdE9yT3B0aW9ucywgb3ZlcnJpZGVzLCBmb3JtYXRzPy5udW1iZXIsIG9wdGlvbnMgPT4gZm9ybWF0dGVycy5nZXROdW1iZXJGb3JtYXQobG9jYWxlLCBvcHRpb25zKS5mb3JtYXQodmFsdWUpLCAoKSA9PiBTdHJpbmcodmFsdWUpKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRHbG9iYWxOb3coKSB7XG4gICAgLy8gT25seSByZWFkIHdoZW4gbmVjZXNzYXJ5IHRvIGF2b2lkIHRyaWdnZXJpbmcgYSBgZHluYW1pY0lPYCBlcnJvclxuICAgIC8vIHVubmVjZXNzYXJpbHkgKGBub3dgIGlzIG9ubHkgbmVlZGVkIGZvciBgZm9ybWF0LnJlbGF0aXZlVGltZWApXG4gICAgaWYgKHByb3BzLm5vdykge1xuICAgICAgcmV0dXJuIHByb3BzLm5vdztcbiAgICB9IGVsc2Uge1xuICAgICAgb25FcnJvcihuZXcgSW50bEVycm9yKEludGxFcnJvckNvZGUuRU5WSVJPTk1FTlRfRkFMTEJBQ0ssIGBUaGUgXFxgbm93XFxgIHBhcmFtZXRlciB3YXNuJ3QgcHJvdmlkZWQgdG8gXFxgcmVsYXRpdmVUaW1lXFxgIGFuZCB0aGVyZSBpcyBubyBnbG9iYWwgZGVmYXVsdCBjb25maWd1cmVkLCB0aGVyZWZvcmUgdGhlIGN1cnJlbnQgdGltZSB3aWxsIGJlIHVzZWQgYXMgYSBmYWxsYmFjay4gU2VlIGh0dHBzOi8vbmV4dC1pbnRsLmRldi9kb2NzL3VzYWdlL2RhdGVzLXRpbWVzI3JlbGF0aXZlLXRpbWVzLXVzZW5vd2AgKSk7XG4gICAgICByZXR1cm4gbmV3IERhdGUoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcmVsYXRpdmVUaW1lKGRhdGUsIG5vd09yT3B0aW9ucykge1xuICAgIHRyeSB7XG4gICAgICBsZXQgbm93RGF0ZSwgdW5pdDtcbiAgICAgIGNvbnN0IG9wdHMgPSB7fTtcbiAgICAgIGlmIChub3dPck9wdGlvbnMgaW5zdGFuY2VvZiBEYXRlIHx8IHR5cGVvZiBub3dPck9wdGlvbnMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIG5vd0RhdGUgPSBuZXcgRGF0ZShub3dPck9wdGlvbnMpO1xuICAgICAgfSBlbHNlIGlmIChub3dPck9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG5vd09yT3B0aW9ucy5ub3cgIT0gbnVsbCkge1xuICAgICAgICAgIG5vd0RhdGUgPSBuZXcgRGF0ZShub3dPck9wdGlvbnMubm93KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub3dEYXRlID0gZ2V0R2xvYmFsTm93KCk7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdCA9IG5vd09yT3B0aW9ucy51bml0O1xuICAgICAgICBvcHRzLnN0eWxlID0gbm93T3JPcHRpb25zLnN0eWxlO1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0tIFR5cGVzIGFyZSBzbGlnaHRseSBvdXRkYXRlZFxuICAgICAgICBvcHRzLm51bWJlcmluZ1N5c3RlbSA9IG5vd09yT3B0aW9ucy5udW1iZXJpbmdTeXN0ZW07XG4gICAgICB9XG4gICAgICBpZiAoIW5vd0RhdGUpIHtcbiAgICAgICAgbm93RGF0ZSA9IGdldEdsb2JhbE5vdygpO1xuICAgICAgfVxuICAgICAgY29uc3QgZGF0ZURhdGUgPSBuZXcgRGF0ZShkYXRlKTtcbiAgICAgIGNvbnN0IHNlY29uZHMgPSAoZGF0ZURhdGUuZ2V0VGltZSgpIC0gbm93RGF0ZS5nZXRUaW1lKCkpIC8gMTAwMDtcbiAgICAgIGlmICghdW5pdCkge1xuICAgICAgICB1bml0ID0gcmVzb2x2ZVJlbGF0aXZlVGltZVVuaXQoc2Vjb25kcyk7XG4gICAgICB9XG5cbiAgICAgIC8vIGBudW1lcmljOiAnYXV0bydgIGNhbiB0aGVvcmV0aWNhbGx5IHByb2R1Y2Ugb3V0cHV0IGxpa2UgXCJ5ZXN0ZXJkYXlcIixcbiAgICAgIC8vIGJ1dCBpdCBvbmx5IHdvcmtzIHdpdGggaW50ZWdlcnMuIEUuZy4gLTEgZGF5IHdpbGwgcHJvZHVjZSBcInllc3RlcmRheVwiLFxuICAgICAgLy8gYnV0IC0xLjEgZGF5cyB3aWxsIHByb2R1Y2UgXCItMS4xIGRheXNcIi4gUm91bmRpbmcgYmVmb3JlIGZvcm1hdHRpbmcgaXNcbiAgICAgIC8vIG5vdCBkZXNpcmVkLCBhcyB0aGUgZ2l2ZW4gZGF0ZXMgbWlnaHQgY3Jvc3MgYSB0aHJlc2hvbGQgd2VyZSB0aGVcbiAgICAgIC8vIG91dHB1dCBpc24ndCBjb3JyZWN0IGFueW1vcmUuIEV4YW1wbGU6IDIwMjQtMDEtMDhUMjM6MDA6MDAuMDAwWiBhbmRcbiAgICAgIC8vIDIwMjQtMDEtMDhUMDE6MDA6MDAuMDAwWiB3b3VsZCBwcm9kdWNlIFwieWVzdGVyZGF5XCIsIHdoaWNoIGlzIG5vdCB0aGVcbiAgICAgIC8vIGNhc2UuIEJ5IHVzaW5nIGBhbHdheXNgIHdlIGNhbiBlbnN1cmUgY29ycmVjdCBvdXRwdXQuIFRoZSBvbmx5IGV4Y2VwdGlvblxuICAgICAgLy8gaXMgdGhlIGZvcm1hdHRpbmcgb2YgdGltZXMgPDEgc2Vjb25kIGFzIFwibm93XCIuXG4gICAgICBvcHRzLm51bWVyaWMgPSB1bml0ID09PSAnc2Vjb25kJyA/ICdhdXRvJyA6ICdhbHdheXMnO1xuICAgICAgY29uc3QgdmFsdWUgPSBjYWxjdWxhdGVSZWxhdGl2ZVRpbWVWYWx1ZShzZWNvbmRzLCB1bml0KTtcbiAgICAgIHJldHVybiBmb3JtYXR0ZXJzLmdldFJlbGF0aXZlVGltZUZvcm1hdChsb2NhbGUsIG9wdHMpLmZvcm1hdCh2YWx1ZSwgdW5pdCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIG9uRXJyb3IobmV3IEludGxFcnJvcihJbnRsRXJyb3JDb2RlLkZPUk1BVFRJTkdfRVJST1IsIGVycm9yLm1lc3NhZ2UpKTtcbiAgICAgIHJldHVybiBTdHJpbmcoZGF0ZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGxpc3QodmFsdWUsIGZvcm1hdE9yT3B0aW9ucywgb3ZlcnJpZGVzKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZFZhbHVlID0gW107XG4gICAgY29uc3QgcmljaFZhbHVlcyA9IG5ldyBNYXAoKTtcblxuICAgIC8vIGBmb3JtYXRUb1BhcnRzYCBvbmx5IGFjY2VwdHMgc3RyaW5ncywgdGhlcmVmb3JlIHdlIGhhdmUgdG8gdGVtcG9yYXJpbHlcbiAgICAvLyByZXBsYWNlIFJlYWN0IGVsZW1lbnRzIHdpdGggYSBwbGFjZWhvbGRlciBJRCB0aGF0IGNhbiBiZSB1c2VkIHRvIHJldHJpZXZlXG4gICAgLy8gdGhlIG9yaWdpbmFsIHZhbHVlIGFmdGVyd2FyZHMuXG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdmFsdWUpIHtcbiAgICAgIGxldCBzZXJpYWxpemVkSXRlbTtcbiAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgc2VyaWFsaXplZEl0ZW0gPSBTdHJpbmcoaW5kZXgpO1xuICAgICAgICByaWNoVmFsdWVzLnNldChzZXJpYWxpemVkSXRlbSwgaXRlbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXJpYWxpemVkSXRlbSA9IFN0cmluZyhpdGVtKTtcbiAgICAgIH1cbiAgICAgIHNlcmlhbGl6ZWRWYWx1ZS5wdXNoKHNlcmlhbGl6ZWRJdGVtKTtcbiAgICAgIGluZGV4Kys7XG4gICAgfVxuICAgIHJldHVybiBnZXRGb3JtYXR0ZWRWYWx1ZShmb3JtYXRPck9wdGlvbnMsIG92ZXJyaWRlcywgZm9ybWF0cz8ubGlzdCxcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0tIGByaWNoVmFsdWVzLnNpemVgIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSByZXR1cm4gdHlwZSwgYnV0IFR5cGVTY3JpcHQgY2FuJ3QgaW5mZXIgdGhlIG1lYW5pbmcgb2YgdGhpcyBjb3JyZWN0bHlcbiAgICBvcHRpb25zID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGZvcm1hdHRlcnMuZ2V0TGlzdEZvcm1hdChsb2NhbGUsIG9wdGlvbnMpLmZvcm1hdFRvUGFydHMoc2VyaWFsaXplZFZhbHVlKS5tYXAocGFydCA9PiBwYXJ0LnR5cGUgPT09ICdsaXRlcmFsJyA/IHBhcnQudmFsdWUgOiByaWNoVmFsdWVzLmdldChwYXJ0LnZhbHVlKSB8fCBwYXJ0LnZhbHVlKTtcbiAgICAgIGlmIChyaWNoVmFsdWVzLnNpemUgPiAwKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oJycpO1xuICAgICAgfVxuICAgIH0sICgpID0+IFN0cmluZyh2YWx1ZSkpO1xuICB9XG4gIHJldHVybiB7XG4gICAgZGF0ZVRpbWUsXG4gICAgbnVtYmVyLFxuICAgIHJlbGF0aXZlVGltZSxcbiAgICBsaXN0LFxuICAgIGRhdGVUaW1lUmFuZ2VcbiAgfTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVNZXNzYWdlc1NlZ21lbnQobWVzc2FnZXMsIGludmFsaWRLZXlMYWJlbHMsIHBhcmVudFBhdGgpIHtcbiAgT2JqZWN0LmVudHJpZXMobWVzc2FnZXMpLmZvckVhY2goKFtrZXksIG1lc3NhZ2VPck1lc3NhZ2VzXSkgPT4ge1xuICAgIGlmIChrZXkuaW5jbHVkZXMoJy4nKSkge1xuICAgICAgbGV0IGtleUxhYmVsID0ga2V5O1xuICAgICAgaWYgKHBhcmVudFBhdGgpIGtleUxhYmVsICs9IGAgKGF0ICR7cGFyZW50UGF0aH0pYDtcbiAgICAgIGludmFsaWRLZXlMYWJlbHMucHVzaChrZXlMYWJlbCk7XG4gICAgfVxuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cbiAgICBpZiAobWVzc2FnZU9yTWVzc2FnZXMgIT0gbnVsbCAmJiB0eXBlb2YgbWVzc2FnZU9yTWVzc2FnZXMgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YWxpZGF0ZU1lc3NhZ2VzU2VnbWVudChtZXNzYWdlT3JNZXNzYWdlcywgaW52YWxpZEtleUxhYmVscywgam9pblBhdGgocGFyZW50UGF0aCwga2V5KSk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlTWVzc2FnZXMobWVzc2FnZXMsIG9uRXJyb3IpIHtcbiAgY29uc3QgaW52YWxpZEtleUxhYmVscyA9IFtdO1xuICB2YWxpZGF0ZU1lc3NhZ2VzU2VnbWVudChtZXNzYWdlcywgaW52YWxpZEtleUxhYmVscyk7XG4gIGlmIChpbnZhbGlkS2V5TGFiZWxzLmxlbmd0aCA+IDApIHtcbiAgICBvbkVycm9yKG5ldyBJbnRsRXJyb3IoSW50bEVycm9yQ29kZS5JTlZBTElEX0tFWSwgYE5hbWVzcGFjZSBrZXlzIGNhbiBub3QgY29udGFpbiB0aGUgY2hhcmFjdGVyIFwiLlwiIGFzIHRoaXMgaXMgdXNlZCB0byBleHByZXNzIG5lc3RpbmcuIFBsZWFzZSByZW1vdmUgaXQgb3IgcmVwbGFjZSBpdCB3aXRoIGFub3RoZXIgY2hhcmFjdGVyLlxuXG5JbnZhbGlkICR7aW52YWxpZEtleUxhYmVscy5sZW5ndGggPT09IDEgPyAna2V5JyA6ICdrZXlzJ306ICR7aW52YWxpZEtleUxhYmVscy5qb2luKCcsICcpfVxuXG5JZiB5b3UncmUgbWlncmF0aW5nIGZyb20gYSBmbGF0IHN0cnVjdHVyZSwgeW91IGNhbiBjb252ZXJ0IHlvdXIgbWVzc2FnZXMgYXMgZm9sbG93czpcblxuaW1wb3J0IHtzZXR9IGZyb20gXCJsb2Rhc2hcIjtcblxuY29uc3QgaW5wdXQgPSB7XG4gIFwib25lLm9uZVwiOiBcIjEuMVwiLFxuICBcIm9uZS50d29cIjogXCIxLjJcIixcbiAgXCJ0d28ub25lLm9uZVwiOiBcIjIuMS4xXCJcbn07XG5cbmNvbnN0IG91dHB1dCA9IE9iamVjdC5lbnRyaWVzKGlucHV0KS5yZWR1Y2UoXG4gIChhY2MsIFtrZXksIHZhbHVlXSkgPT4gc2V0KGFjYywga2V5LCB2YWx1ZSksXG4gIHt9XG4pO1xuXG4vLyBPdXRwdXQ6XG4vL1xuLy8ge1xuLy8gICBcIm9uZVwiOiB7XG4vLyAgICAgXCJvbmVcIjogXCIxLjFcIixcbi8vICAgICBcInR3b1wiOiBcIjEuMlwiXG4vLyAgIH0sXG4vLyAgIFwidHdvXCI6IHtcbi8vICAgICBcIm9uZVwiOiB7XG4vLyAgICAgICBcIm9uZVwiOiBcIjIuMS4xXCJcbi8vICAgICB9XG4vLyAgIH1cbi8vIH1cbmAgKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBFbmhhbmNlcyB0aGUgaW5jb21pbmcgcHJvcHMgd2l0aCBkZWZhdWx0cy5cbiAqL1xuZnVuY3Rpb24gaW5pdGlhbGl6ZUNvbmZpZyh7XG4gIGZvcm1hdHMsXG4gIGdldE1lc3NhZ2VGYWxsYmFjayxcbiAgbWVzc2FnZXMsXG4gIG9uRXJyb3IsXG4gIC4uLnJlc3Rcbn0pIHtcbiAgY29uc3QgZmluYWxPbkVycm9yID0gb25FcnJvciB8fCBkZWZhdWx0T25FcnJvcjtcbiAgY29uc3QgZmluYWxHZXRNZXNzYWdlRmFsbGJhY2sgPSBnZXRNZXNzYWdlRmFsbGJhY2sgfHwgZGVmYXVsdEdldE1lc3NhZ2VGYWxsYmFjaztcbiAge1xuICAgIGlmIChtZXNzYWdlcykge1xuICAgICAgdmFsaWRhdGVNZXNzYWdlcyhtZXNzYWdlcywgZmluYWxPbkVycm9yKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5yZXN0LFxuICAgIGZvcm1hdHM6IGZvcm1hdHMgfHwgdW5kZWZpbmVkLFxuICAgIG1lc3NhZ2VzOiBtZXNzYWdlcyB8fCB1bmRlZmluZWQsXG4gICAgb25FcnJvcjogZmluYWxPbkVycm9yLFxuICAgIGdldE1lc3NhZ2VGYWxsYmFjazogZmluYWxHZXRNZXNzYWdlRmFsbGJhY2tcbiAgfTtcbn1cblxuZXhwb3J0IHsgSW50bEVycm9yIGFzIEksIEludGxFcnJvckNvZGUgYXMgYSwgY3JlYXRlSW50bEZvcm1hdHRlcnMgYXMgYiwgY3JlYXRlRm9ybWF0dGVyIGFzIGMsIGNyZWF0ZUNhY2hlIGFzIGQsIGNyZWF0ZUJhc2VUcmFuc2xhdG9yIGFzIGUsIGRlZmF1bHRHZXRNZXNzYWdlRmFsbGJhY2sgYXMgZiwgZGVmYXVsdE9uRXJyb3IgYXMgZywgaW5pdGlhbGl6ZUNvbmZpZyBhcyBpLCByZXNvbHZlTmFtZXNwYWNlIGFzIHIgfTtcbiJdLCJuYW1lcyI6WyJJbnRsTWVzc2FnZUZvcm1hdCIsImlzVmFsaWRFbGVtZW50IiwiY2xvbmVFbGVtZW50IiwibWVtb2l6ZSIsInN0cmF0ZWdpZXMiLCJJbnRsRXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwiY29kZSIsIm9yaWdpbmFsTWVzc2FnZSIsIm1lc3NhZ2UiLCJJbnRsRXJyb3JDb2RlIiwiY29udmVydEZvcm1hdHNUb0ludGxNZXNzYWdlRm9ybWF0IiwiZ2xvYmFsRm9ybWF0cyIsImlubGluZUZvcm1hdHMiLCJ0aW1lWm9uZSIsIm1mRGF0ZURlZmF1bHRzIiwiZm9ybWF0cyIsImRhdGUiLCJtZlRpbWVEZWZhdWx0cyIsInRpbWUiLCJkYXRlVGltZUZvcm1hdHMiLCJfb2JqZWN0U3ByZWFkIiwiZGF0ZVRpbWUiLCJhbGxGb3JtYXRzIiwibnVtYmVyIiwiZm9yRWFjaCIsInByb3BlcnR5Iiwia2V5IiwidmFsdWUiLCJPYmplY3QiLCJlbnRyaWVzIiwiam9pblBhdGgiLCJwYXJ0cyIsImZpbHRlciIsIkJvb2xlYW4iLCJqb2luIiwiZGVmYXVsdEdldE1lc3NhZ2VGYWxsYmFjayIsInByb3BzIiwibmFtZXNwYWNlIiwiZGVmYXVsdE9uRXJyb3IiLCJlcnJvciIsImNvbnNvbGUiLCJjcmVhdGVDYWNoZSIsInJlbGF0aXZlVGltZSIsInBsdXJhbFJ1bGVzIiwibGlzdCIsImRpc3BsYXlOYW1lcyIsImNyZWF0ZU1lbW9DYWNoZSIsInN0b3JlIiwiY3JlYXRlIiwiZ2V0Iiwic2V0IiwibWVtb0ZuIiwiZm4iLCJjYWNoZSIsInN0cmF0ZWd5IiwidmFyaWFkaWMiLCJtZW1vQ29uc3RydWN0b3IiLCJDb25zdHJ1Y3RvckZuIiwiYXJncyIsImNyZWF0ZUludGxGb3JtYXR0ZXJzIiwiZ2V0RGF0ZVRpbWVGb3JtYXQiLCJJbnRsIiwiRGF0ZVRpbWVGb3JtYXQiLCJnZXROdW1iZXJGb3JtYXQiLCJOdW1iZXJGb3JtYXQiLCJnZXRQbHVyYWxSdWxlcyIsIlBsdXJhbFJ1bGVzIiwiZ2V0UmVsYXRpdmVUaW1lRm9ybWF0IiwiUmVsYXRpdmVUaW1lRm9ybWF0IiwiZ2V0TGlzdEZvcm1hdCIsIkxpc3RGb3JtYXQiLCJnZXREaXNwbGF5TmFtZXMiLCJEaXNwbGF5TmFtZXMiLCJjcmVhdGVNZXNzYWdlRm9ybWF0dGVyIiwiaW50bEZvcm1hdHRlcnMiLCJnZXRNZXNzYWdlRm9ybWF0IiwiZm9ybWF0dGVycyIsInJlc29sdmVQYXRoIiwibG9jYWxlIiwibWVzc2FnZXMiLCJmdWxsS2V5Iiwic3BsaXQiLCJwYXJ0IiwibmV4dCIsInByZXBhcmVUcmFuc2xhdGlvblZhbHVlcyIsInZhbHVlcyIsInRyYW5zZm9ybWVkVmFsdWVzIiwia2V5cyIsImluZGV4IiwidHJhbnNmb3JtZWQiLCJjaHVua3MiLCJyZXN1bHQiLCJnZXRNZXNzYWdlc09yRXJyb3IiLCJvbkVycm9yIiwicmV0cmlldmVkTWVzc2FnZXMiLCJpbnRsRXJyb3IiLCJNSVNTSU5HX01FU1NBR0UiLCJnZXRQbGFpbk1lc3NhZ2UiLCJjYW5kaWRhdGUiLCJ0ZXN0IiwidW5kZWZpbmVkIiwiY3JlYXRlQmFzZVRyYW5zbGF0b3IiLCJjb25maWciLCJtZXNzYWdlc09yRXJyb3IiLCJjcmVhdGVCYXNlVHJhbnNsYXRvckltcGwiLCJnZXRNZXNzYWdlRmFsbGJhY2siLCJoYXNNZXNzYWdlc0Vycm9yIiwiZ2V0RmFsbGJhY2tGcm9tRXJyb3JBbmROb3RpZnkiLCJ0cmFuc2xhdGVCYXNlRm4iLCJlcnJvck1lc3NhZ2UiLCJBcnJheSIsImlzQXJyYXkiLCJJTlZBTElEX01FU1NBR0UiLCJJTlNVRkZJQ0lFTlRfUEFUSCIsIm1lc3NhZ2VGb3JtYXQiLCJwbGFpbk1lc3NhZ2UiLCJsb2NhbGVzIiwib3B0aW9ucyIsInRocm93bkVycm9yIiwiZm9ybWF0dGVkTWVzc2FnZSIsImZvcm1hdCIsIlN0cmluZyIsIkZPUk1BVFRJTkdfRVJST1IiLCJ0cmFuc2xhdGVGbiIsInJpY2giLCJtYXJrdXAiLCJyYXciLCJoYXMiLCJyZXNvbHZlTmFtZXNwYWNlIiwibmFtZXNwYWNlUHJlZml4Iiwic2xpY2UiLCJsZW5ndGgiLCJTRUNPTkQiLCJNSU5VVEUiLCJIT1VSIiwiREFZIiwiV0VFSyIsIk1PTlRIIiwiUVVBUlRFUiIsIllFQVIiLCJVTklUX1NFQ09ORFMiLCJzZWNvbmQiLCJzZWNvbmRzIiwibWludXRlIiwibWludXRlcyIsImhvdXIiLCJob3VycyIsImRheSIsImRheXMiLCJ3ZWVrIiwid2Vla3MiLCJtb250aCIsIm1vbnRocyIsInF1YXJ0ZXIiLCJxdWFydGVycyIsInllYXIiLCJ5ZWFycyIsInJlc29sdmVSZWxhdGl2ZVRpbWVVbml0IiwiYWJzVmFsdWUiLCJNYXRoIiwiYWJzIiwiY2FsY3VsYXRlUmVsYXRpdmVUaW1lVmFsdWUiLCJ1bml0Iiwicm91bmQiLCJjcmVhdGVGb3JtYXR0ZXIiLCJfY2FjaGUiLCJfZm9ybWF0dGVycyIsImdsb2JhbFRpbWVab25lIiwiYXBwbHlUaW1lWm9uZSIsIkVOVklST05NRU5UX0ZBTExCQUNLIiwicmVzb2x2ZUZvcm1hdE9yT3B0aW9ucyIsInR5cGVGb3JtYXRzIiwiZm9ybWF0T3JPcHRpb25zIiwib3ZlcnJpZGVzIiwiZm9ybWF0TmFtZSIsIk1JU1NJTkdfRk9STUFUIiwiZ2V0Rm9ybWF0dGVkVmFsdWUiLCJmb3JtYXR0ZXIiLCJnZXRGYWxsYmFjayIsImRhdGVUaW1lUmFuZ2UiLCJzdGFydCIsImVuZCIsImZvcm1hdFJhbmdlIiwiZ2V0R2xvYmFsTm93Iiwibm93IiwiRGF0ZSIsIm5vd09yT3B0aW9ucyIsIm5vd0RhdGUiLCJvcHRzIiwic3R5bGUiLCJudW1iZXJpbmdTeXN0ZW0iLCJkYXRlRGF0ZSIsImdldFRpbWUiLCJudW1lcmljIiwic2VyaWFsaXplZFZhbHVlIiwicmljaFZhbHVlcyIsIk1hcCIsIml0ZW0iLCJzZXJpYWxpemVkSXRlbSIsInB1c2giLCJmb3JtYXRUb1BhcnRzIiwibWFwIiwidHlwZSIsInNpemUiLCJ2YWxpZGF0ZU1lc3NhZ2VzU2VnbWVudCIsImludmFsaWRLZXlMYWJlbHMiLCJwYXJlbnRQYXRoIiwibWVzc2FnZU9yTWVzc2FnZXMiLCJpbmNsdWRlcyIsImtleUxhYmVsIiwidmFsaWRhdGVNZXNzYWdlcyIsIklOVkFMSURfS0VZIiwiaW5pdGlhbGl6ZUNvbmZpZyIsIl9yZWYiLCJyZXN0IiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIiwiX2V4Y2x1ZGVkIiwiZmluYWxPbkVycm9yIiwiZmluYWxHZXRNZXNzYWdlRmFsbGJhY2siLCJJIiwiYSIsImIiLCJjIiwiZCIsImUiLCJmIiwiZyIsImkiLCJyIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/use-intl/dist/esm/development/initializeConfig-DPFnvsUO.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/use-intl/dist/esm/development/react.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/use-intl/dist/esm/development/react.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IntlProvider: () => (/* binding */ IntlProvider),\n/* harmony export */   useFormatter: () => (/* binding */ useFormatter),\n/* harmony export */   useLocale: () => (/* binding */ useLocale),\n/* harmony export */   useMessages: () => (/* binding */ useMessages),\n/* harmony export */   useNow: () => (/* binding */ useNow),\n/* harmony export */   useTimeZone: () => (/* binding */ useTimeZone),\n/* harmony export */   useTranslations: () => (/* binding */ useTranslations)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/../../node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _initializeConfig_DPFnvsUO_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./initializeConfig-DPFnvsUO.js */ \"(ssr)/../../node_modules/use-intl/dist/esm/development/initializeConfig-DPFnvsUO.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/../../node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\n\n\nconst IntlContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(undefined);\nfunction IntlProvider({\n  children,\n  formats,\n  getMessageFallback,\n  locale,\n  messages,\n  now,\n  onError,\n  timeZone\n}) {\n  const prevContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(IntlContext);\n\n  // The formatter cache is released when the locale changes. For\n  // long-running apps with a persistent `IntlProvider` at the root,\n  // this can reduce the memory footprint (e.g. in React Native).\n  const cache = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return prevContext?.cache || (0,_initializeConfig_DPFnvsUO_js__WEBPACK_IMPORTED_MODULE_2__.d)();\n  }, [locale, prevContext?.cache]);\n  const formatters = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => prevContext?.formatters || (0,_initializeConfig_DPFnvsUO_js__WEBPACK_IMPORTED_MODULE_2__.b)(cache), [cache, prevContext?.formatters]);\n\n  // Memoizing this value helps to avoid triggering a re-render of all\n  // context consumers in case the configuration didn't change. However,\n  // if some of the non-primitive values change, a re-render will still\n  // be triggered. Note that there's no need to put `memo` on `IntlProvider`\n  // itself, because the `children` typically change on every render.\n  // There's some burden on the consumer side if it's important to reduce\n  // re-renders, put that's how React works.\n  // See: https://blog.isquaredsoftware.com/2020/05/blogged-answers-a-mostly-complete-guide-to-react-rendering-behavior/#context-updates-and-render-optimizations\n  const value = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => _objectSpread(_objectSpread({}, (0,_initializeConfig_DPFnvsUO_js__WEBPACK_IMPORTED_MODULE_2__.i)({\n    locale,\n    // (required by provider)\n    formats: formats === undefined ? prevContext?.formats : formats,\n    getMessageFallback: getMessageFallback || prevContext?.getMessageFallback,\n    messages: messages === undefined ? prevContext?.messages : messages,\n    now: now || prevContext?.now,\n    onError: onError || prevContext?.onError,\n    timeZone: timeZone || prevContext?.timeZone\n  })), {}, {\n    formatters,\n    cache\n  }), [cache, formats, formatters, getMessageFallback, locale, messages, now, onError, prevContext, timeZone]);\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(IntlContext.Provider, {\n    value: value,\n    children: children\n  });\n}\nfunction useIntlContext() {\n  const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(IntlContext);\n  if (!context) {\n    throw new Error('No intl context found. Have you configured the provider? See https://next-intl.dev/docs/usage/configuration#server-client-components');\n  }\n  return context;\n}\nlet hasWarnedForMissingTimezone = false;\nconst isServer = true;\nfunction useTranslationsImpl(allMessagesPrefixed, namespacePrefixed, namespacePrefix) {\n  const {\n    cache,\n    formats: globalFormats,\n    formatters,\n    getMessageFallback,\n    locale,\n    onError,\n    timeZone\n  } = useIntlContext();\n\n  // The `namespacePrefix` is part of the type system.\n  // See the comment in the hook invocation.\n  const allMessages = allMessagesPrefixed[namespacePrefix];\n  const namespace = (0,_initializeConfig_DPFnvsUO_js__WEBPACK_IMPORTED_MODULE_2__.r)(namespacePrefixed, namespacePrefix);\n  if (!timeZone && !hasWarnedForMissingTimezone && isServer) {\n    // eslint-disable-next-line react-compiler/react-compiler\n    hasWarnedForMissingTimezone = true;\n    onError(new _initializeConfig_DPFnvsUO_js__WEBPACK_IMPORTED_MODULE_2__.I(_initializeConfig_DPFnvsUO_js__WEBPACK_IMPORTED_MODULE_2__.a.ENVIRONMENT_FALLBACK, `There is no \\`timeZone\\` configured, this can lead to markup mismatches caused by environment differences. Consider adding a global default: https://next-intl.dev/docs/configuration#time-zone`));\n  }\n  const translate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => (0,_initializeConfig_DPFnvsUO_js__WEBPACK_IMPORTED_MODULE_2__.e)({\n    cache,\n    formatters,\n    getMessageFallback,\n    messages: allMessages,\n    namespace,\n    onError,\n    formats: globalFormats,\n    locale,\n    timeZone\n  }), [cache, formatters, getMessageFallback, allMessages, namespace, onError, globalFormats, locale, timeZone]);\n  return translate;\n}\n\n/**\n * Translates messages from the given namespace by using the ICU syntax.\n * See https://formatjs.io/docs/core-concepts/icu-syntax.\n *\n * If no namespace is provided, all available messages are returned.\n * The namespace can also indicate nesting by using a dot\n * (e.g. `namespace.Component`).\n */\nfunction useTranslations(namespace) {\n  const context = useIntlContext();\n  const messages = context.messages;\n\n  // We have to wrap the actual hook so the type inference for the optional\n  // namespace works correctly. See https://stackoverflow.com/a/71529575/343045\n  // The prefix (\"!\") is arbitrary.\n  // @ts-expect-error Use the explicit annotation instead\n  return useTranslationsImpl({\n    '!': messages\n  },\n  // @ts-expect-error\n  namespace ? `!.${namespace}` : '!', '!');\n}\nfunction useLocale() {\n  return useIntlContext().locale;\n}\nfunction getNow() {\n  return new Date();\n}\n\n/**\n * @see https://next-intl.dev/docs/usage/dates-times#relative-times-usenow\n */\nfunction useNow(options) {\n  const updateInterval = options?.updateInterval;\n  const {\n    now: globalNow\n  } = useIntlContext();\n  const {\n    0: now,\n    1: setNow\n  } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(globalNow || getNow());\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!updateInterval) return;\n    const intervalId = setInterval(() => {\n      setNow(getNow());\n    }, updateInterval);\n    return () => {\n      clearInterval(intervalId);\n    };\n  }, [globalNow, updateInterval]);\n  return updateInterval == null && globalNow ? globalNow : now;\n}\nfunction useTimeZone() {\n  return useIntlContext().timeZone;\n}\nfunction useMessages() {\n  const context = useIntlContext();\n  if (!context.messages) {\n    throw new Error('No messages found. Have you configured them correctly? See https://next-intl.dev/docs/configuration#messages');\n  }\n  return context.messages;\n}\nfunction useFormatter() {\n  const {\n    formats,\n    formatters,\n    locale,\n    now: globalNow,\n    onError,\n    timeZone\n  } = useIntlContext();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => (0,_initializeConfig_DPFnvsUO_js__WEBPACK_IMPORTED_MODULE_2__.c)({\n    formats,\n    locale,\n    now: globalNow,\n    onError,\n    timeZone,\n    _formatters: formatters\n  }), [formats, formatters, globalNow, locale, onError, timeZone]);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL3VzZS1pbnRsL2Rpc3QvZXNtL2RldmVsb3BtZW50L3JlYWN0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFnRjtBQUNnSjtBQUN4TDtBQUl4QyxNQUFNc0IsV0FBVyxHQUFHLGFBQWF0QixvREFBYSxDQUFDdUIsU0FBUyxDQUFDO0FBRXpELFNBQVNDLFlBQVlBLENBQUM7RUFDcEJDLFFBQVE7RUFDUkMsT0FBTztFQUNQQyxrQkFBa0I7RUFDbEJDLE1BQU07RUFDTkMsUUFBUTtFQUNSQyxHQUFHO0VBQ0hDLE9BQU87RUFDUEM7QUFDRixDQUFDLEVBQUU7RUFDRCxNQUFNQyxXQUFXLEdBQUdoQyxpREFBVSxDQUFDcUIsV0FBVyxDQUFDOztFQUUzQztFQUNBO0VBQ0E7RUFDQSxNQUFNWSxLQUFLLEdBQUdoQyw4Q0FBTyxDQUFDLE1BQU07SUFDMUIsT0FBTytCLFdBQVcsRUFBRUMsS0FBSyxJQUFJNUIsZ0VBQVcsQ0FBQyxDQUFDO0VBQzVDLENBQUMsRUFBRSxDQUFDc0IsTUFBTSxFQUFFSyxXQUFXLEVBQUVDLEtBQUssQ0FBQyxDQUFDO0VBQ2hDLE1BQU1DLFVBQVUsR0FBR2pDLDhDQUFPLENBQUMsTUFBTStCLFdBQVcsRUFBRUUsVUFBVSxJQUFJM0IsZ0VBQW9CLENBQUMwQixLQUFLLENBQUMsRUFBRSxDQUFDQSxLQUFLLEVBQUVELFdBQVcsRUFBRUUsVUFBVSxDQUFDLENBQUM7O0VBRTFIO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQSxNQUFNQyxLQUFLLEdBQUdsQyw4Q0FBTyxDQUFDLE1BQUFtQyxhQUFBLENBQUFBLGFBQUEsS0FDakIzQixnRUFBZ0IsQ0FBQztJQUNsQmtCLE1BQU07SUFDTjtJQUNBRixPQUFPLEVBQUVBLE9BQU8sS0FBS0gsU0FBUyxHQUFHVSxXQUFXLEVBQUVQLE9BQU8sR0FBR0EsT0FBTztJQUMvREMsa0JBQWtCLEVBQUVBLGtCQUFrQixJQUFJTSxX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LEVBQUU7SUFDckIsTUFBTSxJQUFJWSxLQUFLLENBQUMsOEdBQStHLENBQUM7RUFDbEk7RUFDQSxPQUFPRCxPQUFPLENBQUNYLFFBQVE7QUFDekI7QUFFQSxTQUFTc0MsWUFBWUEsQ0FBQSxFQUFHO0VBQ3RCLE1BQU07SUFDSnpDLE9BQU87SUFDUFMsVUFBVTtJQUNWUCxNQUFNO0lBQ05FLEdBQUcsRUFBRThCLFNBQVM7SUFDZDdCLE9BQU87SUFDUEM7RUFDRixDQUFDLEdBQUdPLGNBQWMsQ0FBQyxDQUFDO0VBQ3BCLE9BQU9yQyw4Q0FBTyxDQUFDLE1BQU1rQixnRUFBZSxDQUFDO0lBQ25DTSxPQUFPO0lBQ1BFLE1BQU07SUFDTkUsR0FBRyxFQUFFOEIsU0FBUztJQUNkN0IsT0FBTztJQUNQQyxRQUFRO0lBQ1JvQyxXQUFXLEVBQUVqQztFQUNmLENBQUMsQ0FBQyxFQUFFLENBQUNULE9BQU8sRUFBRVMsVUFBVSxFQUFFeUIsU0FBUyxFQUFFaEMsTUFBTSxFQUFFRyxPQUFPLEVBQUVDLFFBQVEsQ0FBQyxDQUFDO0FBQ2xFIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFETUlOXFxPbmVEcml2ZVxcRGVza3RvcFxcSW0gYSBiaXJkZGRkZGRkXFxub2RlX21vZHVsZXNcXHVzZS1pbnRsXFxkaXN0XFxlc21cXGRldmVsb3BtZW50XFxyZWFjdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VNZW1vLCB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZCBhcyBjcmVhdGVDYWNoZSwgYiBhcyBjcmVhdGVJbnRsRm9ybWF0dGVycywgaSBhcyBpbml0aWFsaXplQ29uZmlnLCByIGFzIHJlc29sdmVOYW1lc3BhY2UsIEkgYXMgSW50bEVycm9yLCBhIGFzIEludGxFcnJvckNvZGUsIGUgYXMgY3JlYXRlQmFzZVRyYW5zbGF0b3IsIGMgYXMgY3JlYXRlRm9ybWF0dGVyIH0gZnJvbSAnLi9pbml0aWFsaXplQ29uZmlnLURQRm52c1VPLmpzJztcbmltcG9ydCB7IGpzeCB9IGZyb20gJ3JlYWN0L2pzeC1ydW50aW1lJztcblxuXG5cbmNvbnN0IEludGxDb250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbnRleHQodW5kZWZpbmVkKTtcblxuZnVuY3Rpb24gSW50bFByb3ZpZGVyKHtcbiAgY2hpbGRyZW4sXG4gIGZvcm1hdHMsXG4gIGdldE1lc3NhZ2VGYWxsYmFjayxcbiAgbG9jYWxlLFxuICBtZXNzYWdlcyxcbiAgbm93LFxuICBvbkVycm9yLFxuICB0aW1lWm9uZVxufSkge1xuICBjb25zdCBwcmV2Q29udGV4dCA9IHVzZUNvbnRleHQoSW50bENvbnRleHQpO1xuXG4gIC8vIFRoZSBmb3JtYXR0ZXIgY2FjaGUgaXMgcmVsZWFzZWQgd2hlbiB0aGUgbG9jYWxlIGNoYW5nZXMuIEZvclxuICAvLyBsb25nLXJ1bm5pbmcgYXBwcyB3aXRoIGEgcGVyc2lzdGVudCBgSW50bFByb3ZpZGVyYCBhdCB0aGUgcm9vdCxcbiAgLy8gdGhpcyBjYW4gcmVkdWNlIHRoZSBtZW1vcnkgZm9vdHByaW50IChlLmcuIGluIFJlYWN0IE5hdGl2ZSkuXG4gIGNvbnN0IGNhY2hlID0gdXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIHByZXZDb250ZXh0Py5jYWNoZSB8fCBjcmVhdGVDYWNoZSgpO1xuICB9LCBbbG9jYWxlLCBwcmV2Q29udGV4dD8uY2FjaGVdKTtcbiAgY29uc3QgZm9ybWF0dGVycyA9IHVzZU1lbW8oKCkgPT4gcHJldkNvbnRleHQ/LmZvcm1hdHRlcnMgfHwgY3JlYXRlSW50bEZvcm1hdHRlcnMoY2FjaGUpLCBbY2FjaGUsIHByZXZDb250ZXh0Py5mb3JtYXR0ZXJzXSk7XG5cbiAgLy8gTWVtb2l6aW5nIHRoaXMgdmFsdWUgaGVscHMgdG8gYXZvaWQgdHJpZ2dlcmluZyBhIHJlLXJlbmRlciBvZiBhbGxcbiAgLy8gY29udGV4dCBjb25zdW1lcnMgaW4gY2FzZSB0aGUgY29uZmlndXJhdGlvbiBkaWRuJ3QgY2hhbmdlLiBIb3dldmVyLFxuICAvLyBpZiBzb21lIG9mIHRoZSBub24tcHJpbWl0aXZlIHZhbHVlcyBjaGFuZ2UsIGEgcmUtcmVuZGVyIHdpbGwgc3RpbGxcbiAgLy8gYmUgdHJpZ2dlcmVkLiBOb3RlIHRoYXQgdGhlcmUncyBubyBuZWVkIHRvIHB1dCBgbWVtb2Agb24gYEludGxQcm92aWRlcmBcbiAgLy8gaXRzZWxmLCBiZWNhdXNlIHRoZSBgY2hpbGRyZW5gIHR5cGljYWxseSBjaGFuZ2Ugb24gZXZlcnkgcmVuZGVyLlxuICAvLyBUaGVyZSdzIHNvbWUgYnVyZGVuIG9uIHRoZSBjb25zdW1lciBzaWRlIGlmIGl0J3MgaW1wb3J0YW50IHRvIHJlZHVjZVxuICAvLyByZS1yZW5kZXJzLCBwdXQgdGhhdCdzIGhvdyBSZWFjdCB3b3Jrcy5cbiAgLy8gU2VlOiBodHRwczovL2Jsb2cuaXNxdWFyZWRzb2Z0d2FyZS5jb20vMjAyMC8wNS9ibG9nZ2VkLWFuc3dlcnMtYS1tb3N0bHktY29tcGxldGUtZ3VpZGUtdG8tcmVhY3QtcmVuZGVyaW5nLWJlaGF2aW9yLyNjb250ZXh0LXVwZGF0ZXMtYW5kLXJlbmRlci1vcHRpbWl6YXRpb25zXG4gIGNvbnN0IHZhbHVlID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIC4uLmluaXRpYWxpemVDb25maWcoe1xuICAgICAgbG9jYWxlLFxuICAgICAgLy8gKHJlcXVpcmVkIGJ5IHByb3ZpZGVyKVxuICAgICAgZm9ybWF0czogZm9ybWF0cyA9PT0gdW5kZWZpbmVkID8gcHJldkNvbnRleHQ/LmZvcm1hdHMgOiBmb3JtYXRzLFxuICAgICAgZ2V0TWVzc2FnZUZhbGxiYWNrOiBnZXRNZXNzYWdlRmFsbGJhY2sgfHwgcHJldkNvbnRleHQ/LmdldE1lc3NhZ2VGYWxsYmFjayxcbiAgICAgIG1lc3NhZ2VzOiBtZXNzYWdlcyA9PT0gdW5kZWZpbmVkID8gcHJldkNvbnRleHQ/Lm1lc3NhZ2VzIDogbWVzc2FnZXMsXG4gICAgICBub3c6IG5vdyB8fCBwcmV2Q29udGV4dD8ubm93LFxuICAgICAgb25FcnJvcjogb25FcnJvciB8fCBwcmV2Q29udGV4dD8ub25FcnJvcixcbiAgICAgIHRpbWVab25lOiB0aW1lWm9uZSB8fCBwcmV2Q29udGV4dD8udGltZVpvbmVcbiAgICB9KSxcbiAgICBmb3JtYXR0ZXJzLFxuICAgIGNhY2hlXG4gIH0pLCBbY2FjaGUsIGZvcm1hdHMsIGZvcm1hdHRlcnMsIGdldE1lc3NhZ2VGYWxsYmFjaywgbG9jYWxlLCBtZXNzYWdlcywgbm93LCBvbkVycm9yLCBwcmV2Q29udGV4dCwgdGltZVpvbmVdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goSW50bENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gIH0pO1xufVxuXG5mdW5jdGlvbiB1c2VJbnRsQ29udGV4dCgpIHtcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoSW50bENvbnRleHQpO1xuICBpZiAoIWNvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGludGwgY29udGV4dCBmb3VuZC4gSGF2ZSB5b3UgY29uZmlndXJlZCB0aGUgcHJvdmlkZXI/IFNlZSBodHRwczovL25leHQtaW50bC5kZXYvZG9jcy91c2FnZS9jb25maWd1cmF0aW9uI3NlcnZlci1jbGllbnQtY29tcG9uZW50cycgKTtcbiAgfVxuICByZXR1cm4gY29udGV4dDtcbn1cblxubGV0IGhhc1dhcm5lZEZvck1pc3NpbmdUaW1lem9uZSA9IGZhbHNlO1xuY29uc3QgaXNTZXJ2ZXIgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJztcbmZ1bmN0aW9uIHVzZVRyYW5zbGF0aW9uc0ltcGwoYWxsTWVzc2FnZXNQcmVmaXhlZCwgbmFtZXNwYWNlUHJlZml4ZWQsIG5hbWVzcGFjZVByZWZpeCkge1xuICBjb25zdCB7XG4gICAgY2FjaGUsXG4gICAgZm9ybWF0czogZ2xvYmFsRm9ybWF0cyxcbiAgICBmb3JtYXR0ZXJzLFxuICAgIGdldE1lc3NhZ2VGYWxsYmFjayxcbiAgICBsb2NhbGUsXG4gICAgb25FcnJvcixcbiAgICB0aW1lWm9uZVxuICB9ID0gdXNlSW50bENvbnRleHQoKTtcblxuICAvLyBUaGUgYG5hbWVzcGFjZVByZWZpeGAgaXMgcGFydCBvZiB0aGUgdHlwZSBzeXN0ZW0uXG4gIC8vIFNlZSB0aGUgY29tbWVudCBpbiB0aGUgaG9vayBpbnZvY2F0aW9uLlxuICBjb25zdCBhbGxNZXNzYWdlcyA9IGFsbE1lc3NhZ2VzUHJlZml4ZWRbbmFtZXNwYWNlUHJlZml4XTtcbiAgY29uc3QgbmFtZXNwYWNlID0gcmVzb2x2ZU5hbWVzcGFjZShuYW1lc3BhY2VQcmVmaXhlZCwgbmFtZXNwYWNlUHJlZml4KTtcbiAgaWYgKCF0aW1lWm9uZSAmJiAhaGFzV2FybmVkRm9yTWlzc2luZ1RpbWV6b25lICYmIGlzU2VydmVyKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWNvbXBpbGVyL3JlYWN0LWNvbXBpbGVyXG4gICAgaGFzV2FybmVkRm9yTWlzc2luZ1RpbWV6b25lID0gdHJ1ZTtcbiAgICBvbkVycm9yKG5ldyBJbnRsRXJyb3IoSW50bEVycm9yQ29kZS5FTlZJUk9OTUVOVF9GQUxMQkFDSywgYFRoZXJlIGlzIG5vIFxcYHRpbWVab25lXFxgIGNvbmZpZ3VyZWQsIHRoaXMgY2FuIGxlYWQgdG8gbWFya3VwIG1pc21hdGNoZXMgY2F1c2VkIGJ5IGVudmlyb25tZW50IGRpZmZlcmVuY2VzLiBDb25zaWRlciBhZGRpbmcgYSBnbG9iYWwgZGVmYXVsdDogaHR0cHM6Ly9uZXh0LWludGwuZGV2L2RvY3MvY29uZmlndXJhdGlvbiN0aW1lLXpvbmVgICkpO1xuICB9XG4gIGNvbnN0IHRyYW5zbGF0ZSA9IHVzZU1lbW8oKCkgPT4gY3JlYXRlQmFzZVRyYW5zbGF0b3Ioe1xuICAgIGNhY2hlLFxuICAgIGZvcm1hdHRlcnMsXG4gICAgZ2V0TWVzc2FnZUZhbGxiYWNrLFxuICAgIG1lc3NhZ2VzOiBhbGxNZXNzYWdlcyxcbiAgICBuYW1lc3BhY2UsXG4gICAgb25FcnJvcixcbiAgICBmb3JtYXRzOiBnbG9iYWxGb3JtYXRzLFxuICAgIGxvY2FsZSxcbiAgICB0aW1lWm9uZVxuICB9KSwgW2NhY2hlLCBmb3JtYXR0ZXJzLCBnZXRNZXNzYWdlRmFsbGJhY2ssIGFsbE1lc3NhZ2VzLCBuYW1lc3BhY2UsIG9uRXJyb3IsIGdsb2JhbEZvcm1hdHMsIGxvY2FsZSwgdGltZVpvbmVdKTtcbiAgcmV0dXJuIHRyYW5zbGF0ZTtcbn1cblxuLyoqXG4gKiBUcmFuc2xhdGVzIG1lc3NhZ2VzIGZyb20gdGhlIGdpdmVuIG5hbWVzcGFjZSBieSB1c2luZyB0aGUgSUNVIHN5bnRheC5cbiAqIFNlZSBodHRwczovL2Zvcm1hdGpzLmlvL2RvY3MvY29yZS1jb25jZXB0cy9pY3Utc3ludGF4LlxuICpcbiAqIElmIG5vIG5hbWVzcGFjZSBpcyBwcm92aWRlZCwgYWxsIGF2YWlsYWJsZSBtZXNzYWdlcyBhcmUgcmV0dXJuZWQuXG4gKiBUaGUgbmFtZXNwYWNlIGNhbiBhbHNvIGluZGljYXRlIG5lc3RpbmcgYnkgdXNpbmcgYSBkb3RcbiAqIChlLmcuIGBuYW1lc3BhY2UuQ29tcG9uZW50YCkuXG4gKi9cbmZ1bmN0aW9uIHVzZVRyYW5zbGF0aW9ucyhuYW1lc3BhY2UpIHtcbiAgY29uc3QgY29udGV4dCA9IHVzZUludGxDb250ZXh0KCk7XG4gIGNvbnN0IG1lc3NhZ2VzID0gY29udGV4dC5tZXNzYWdlcztcblxuICAvLyBXZSBoYXZlIHRvIHdyYXAgdGhlIGFjdHVhbCBob29rIHNvIHRoZSB0eXBlIGluZmVyZW5jZSBmb3IgdGhlIG9wdGlvbmFsXG4gIC8vIG5hbWVzcGFjZSB3b3JrcyBjb3JyZWN0bHkuIFNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNzE1Mjk1NzUvMzQzMDQ1XG4gIC8vIFRoZSBwcmVmaXggKFwiIVwiKSBpcyBhcmJpdHJhcnkuXG4gIC8vIEB0cy1leHBlY3QtZXJyb3IgVXNlIHRoZSBleHBsaWNpdCBhbm5vdGF0aW9uIGluc3RlYWRcbiAgcmV0dXJuIHVzZVRyYW5zbGF0aW9uc0ltcGwoe1xuICAgICchJzogbWVzc2FnZXNcbiAgfSxcbiAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICBuYW1lc3BhY2UgPyBgIS4ke25hbWVzcGFjZX1gIDogJyEnLCAnIScpO1xufVxuXG5mdW5jdGlvbiB1c2VMb2NhbGUoKSB7XG4gIHJldHVybiB1c2VJbnRsQ29udGV4dCgpLmxvY2FsZTtcbn1cblxuZnVuY3Rpb24gZ2V0Tm93KCkge1xuICByZXR1cm4gbmV3IERhdGUoKTtcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vbmV4dC1pbnRsLmRldi9kb2NzL3VzYWdlL2RhdGVzLXRpbWVzI3JlbGF0aXZlLXRpbWVzLXVzZW5vd1xuICovXG5mdW5jdGlvbiB1c2VOb3cob3B0aW9ucykge1xuICBjb25zdCB1cGRhdGVJbnRlcnZhbCA9IG9wdGlvbnM/LnVwZGF0ZUludGVydmFsO1xuICBjb25zdCB7XG4gICAgbm93OiBnbG9iYWxOb3dcbiAgfSA9IHVzZUludGxDb250ZXh0KCk7XG4gIGNvbnN0IFtub3csIHNldE5vd10gPSB1c2VTdGF0ZShnbG9iYWxOb3cgfHwgZ2V0Tm93KCkpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghdXBkYXRlSW50ZXJ2YWwpIHJldHVybjtcbiAgICBjb25zdCBpbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgc2V0Tm93KGdldE5vdygpKTtcbiAgICB9LCB1cGRhdGVJbnRlcnZhbCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJZCk7XG4gICAgfTtcbiAgfSwgW2dsb2JhbE5vdywgdXBkYXRlSW50ZXJ2YWxdKTtcbiAgcmV0dXJuIHVwZGF0ZUludGVydmFsID09IG51bGwgJiYgZ2xvYmFsTm93ID8gZ2xvYmFsTm93IDogbm93O1xufVxuXG5mdW5jdGlvbiB1c2VUaW1lWm9uZSgpIHtcbiAgcmV0dXJuIHVzZUludGxDb250ZXh0KCkudGltZVpvbmU7XG59XG5cbmZ1bmN0aW9uIHVzZU1lc3NhZ2VzKCkge1xuICBjb25zdCBjb250ZXh0ID0gdXNlSW50bENvbnRleHQoKTtcbiAgaWYgKCFjb250ZXh0Lm1lc3NhZ2VzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBtZXNzYWdlcyBmb3VuZC4gSGF2ZSB5b3UgY29uZmlndXJlZCB0aGVtIGNvcnJlY3RseT8gU2VlIGh0dHBzOi8vbmV4dC1pbnRsLmRldi9kb2NzL2NvbmZpZ3VyYXRpb24jbWVzc2FnZXMnICk7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHQubWVzc2FnZXM7XG59XG5cbmZ1bmN0aW9uIHVzZUZvcm1hdHRlcigpIHtcbiAgY29uc3Qge1xuICAgIGZvcm1hdHMsXG4gICAgZm9ybWF0dGVycyxcbiAgICBsb2NhbGUsXG4gICAgbm93OiBnbG9iYWxOb3csXG4gICAgb25FcnJvcixcbiAgICB0aW1lWm9uZVxuICB9ID0gdXNlSW50bENvbnRleHQoKTtcbiAgcmV0dXJuIHVzZU1lbW8oKCkgPT4gY3JlYXRlRm9ybWF0dGVyKHtcbiAgICBmb3JtYXRzLFxuICAgIGxvY2FsZSxcbiAgICBub3c6IGdsb2JhbE5vdyxcbiAgICBvbkVycm9yLFxuICAgIHRpbWVab25lLFxuICAgIF9mb3JtYXR0ZXJzOiBmb3JtYXR0ZXJzXG4gIH0pLCBbZm9ybWF0cywgZm9ybWF0dGVycywgZ2xvYmFsTm93LCBsb2NhbGUsIG9uRXJyb3IsIHRpbWVab25lXSk7XG59XG5cbmV4cG9ydCB7IEludGxQcm92aWRlciwgdXNlRm9ybWF0dGVyLCB1c2VMb2NhbGUsIHVzZU1lc3NhZ2VzLCB1c2VOb3csIHVzZVRpbWVab25lLCB1c2VUcmFuc2xhdGlvbnMgfTtcbiJdLCJuYW1lcyI6WyJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZU1lbW8iLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsImQiLCJjcmVhdGVDYWNoZSIsImIiLCJjcmVhdGVJbnRsRm9ybWF0dGVycyIsImkiLCJpbml0aWFsaXplQ29uZmlnIiwiciIsInJlc29sdmVOYW1lc3BhY2UiLCJJIiwiSW50bEVycm9yIiwiYSIsIkludGxFcnJvckNvZGUiLCJlIiwiY3JlYXRlQmFzZVRyYW5zbGF0b3IiLCJjIiwiY3JlYXRlRm9ybWF0dGVyIiwianN4IiwiSW50bENvbnRleHQiLCJ1bmRlZmluZWQiLCJJbnRsUHJvdmlkZXIiLCJjaGlsZHJlbiIsImZvcm1hdHMiLCJnZXRNZXNzYWdlRmFsbGJhY2siLCJsb2NhbGUiLCJtZXNzYWdlcyIsIm5vdyIsIm9uRXJyb3IiLCJ0aW1lWm9uZSIsInByZXZDb250ZXh0IiwiY2FjaGUiLCJmb3JtYXR0ZXJzIiwidmFsdWUiLCJfb2JqZWN0U3ByZWFkIiwiUHJvdmlkZXIiLCJ1c2VJbnRsQ29udGV4dCIsImNvbnRleHQiLCJFcnJvciIsImhhc1dhcm5lZEZvck1pc3NpbmdUaW1lem9uZSIsImlzU2VydmVyIiwidXNlVHJhbnNsYXRpb25zSW1wbCIsImFsbE1lc3NhZ2VzUHJlZml4ZWQiLCJuYW1lc3BhY2VQcmVmaXhlZCIsIm5hbWVzcGFjZVByZWZpeCIsImdsb2JhbEZvcm1hdHMiLCJhbGxNZXNzYWdlcyIsIm5hbWVzcGFjZSIsIkVOVklST05NRU5UX0ZBTExCQUNLIiwidHJhbnNsYXRlIiwidXNlVHJhbnNsYXRpb25zIiwidXNlTG9jYWxlIiwiZ2V0Tm93IiwiRGF0ZSIsInVzZU5vdyIsIm9wdGlvbnMiLCJ1cGRhdGVJbnRlcnZhbCIsImdsb2JhbE5vdyIsInNldE5vdyIsImludGVydmFsSWQiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJ1c2VUaW1lWm9uZSIsInVzZU1lc3NhZ2VzIiwidXNlRm9ybWF0dGVyIiwiX2Zvcm1hdHRlcnMiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/use-intl/dist/esm/development/react.js\n");

/***/ })

};
;